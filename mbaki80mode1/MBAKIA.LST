    1                   ;       MS-BASIC START UP ROUTINE
    2                   ;       TARGET: AKI-80
    3                   ;       ASSEMBLER: ARCPIT XZ80.EXE
    4                   ;
    5 003F              RBFSIZ     EQU      3FH
    6 8000              RECBUF     EQU      8000H
    7 803F              RBFWTP     EQU      RECBUF+RBFSIZ
    8 003F              RBFLMT     EQU      (RECBUF+RBFSIZ)&0FFH
    9 8041              RBFRDP     EQU      RBFWTP+2
   10 8043              RBFCNT     EQU      RBFRDP+2
   11 8044              FLGBST     EQU      RBFCNT+1
   12 80ED              TSTACK     EQU      80EDH
   13                   ;
   14 0012              PCTCC2     EQU      12H
   15 0018              PSIOAD     EQU      18H
   16 0019              PSIOAC     EQU      19H
   17                   ;
   18 000D              CR         EQU      0DH
   19 000A              LF         EQU      0AH
   20                   ;
   21 0000                         ORG      0000H
   22                   ;
   23                   ;       RESET VECTOR
   24 0000 F3           RST00:     DI
   25 0001 C3A900                  JP       SINIT
   26                   ;
   27                   ;       RESTART VECTOR
   28 0008                         ORG      0008H
   29 0008 C38F00       RST08:     JP       TXA
   30 0010                         ORG      0010H
   31 0010 C36C00       RST10:     JP       RXA
   32 0018                         ORG      0018H
   33 0018 C39A00       RST18:     JP       KBHIT
   34                   ;
   35                   ;       INTERRUPT VECTOR
   36 0038                         ORG      0038H
   37 0038 1800         RST38:     JR       INTRCV
   38                   ;
   39                   ;       SIO -> BUFFER BY INTERRUPT
   40 003A F5           INTRCV:    PUSH     AF
   41 003B E5                      PUSH     HL
   42 003C DB19                    IN       A,(PSIOAC)  ;CHECK RECEIVE
   43 003E CB47                    BIT      0,A
   44 0040 2825                    JR       Z,INTEXT
   45 0042 DB18                    IN       A,(PSIOAD)
   46 0044 F5                      PUSH     AF
   47 0045 3A4380                  LD       A,(RBFCNT)  ;CHECK BUFFER FULL
   48 0048 FE3F                    CP       RBFSIZ
   49 004A 2003                    JR       NZ,NOTFUL
   50 004C F1                      POP      AF
   51 004D 1818                    JR       INTEXT
   52 004F 2A3F80       NOTFUL:    LD       HL,(RBFWTP) ;CHECK WRAP
   53 0052 23                      INC      HL
   54 0053 7D                      LD       A,L
   55 0054 FE3F                    CP       RBFLMT
   56 0056 2003                    JR       NZ,NWWRAP
   57 0058 210080                  LD       HL,RECBUF
   58 005B 223F80       NWWRAP:    LD       (RBFWTP),HL
   59 005E F1                      POP      AF
   60 005F 77                      LD       (HL),A
   61 0060 3A4380                  LD       A,(RBFCNT)
   62 0063 3C                      INC      A
   63 0064 324380                  LD       (RBFCNT),A
   64 0067 E1           INTEXT:    POP      HL
   65 0068 F1                      POP      AF
   66 0069 FB                      EI
   67 006A ED4D                    RETI
   68                   ;
   69                   ;       BUFFER -> A
   70 006C 3A4380       RXA:       LD       A,(RBFCNT)
   71 006F FE00                    CP       00H
   72 0071 28F9                    JR       Z,RXA
   73 0073 E5                      PUSH     HL
   74 0074 2A4180                  LD       HL,(RBFRDP)
   75 0077 23                      INC      HL
   76 0078 7D                      LD       A,L
   77 0079 FE3F                    CP       RBFLMT
   78 007B 2003                    JR       NZ,NRWRAP
   79 007D 210080                  LD       HL,RECBUF
   80 0080 F3           NRWRAP:    DI
   81 0081 224180                  LD       (RBFRDP),HL
   82 0084 3A4380                  LD       A,(RBFCNT)
   83 0087 3D                      DEC      A
   84 0088 324380                  LD       (RBFCNT),A
   85 008B 7E                      LD       A,(HL)
   86 008C FB                      EI
   87 008D E1                      POP      HL
   88 008E C9                      RET
   89                   ;
   90                   ;       A -> SIO
   91 008F F5           TXA:       PUSH     AF
   92 0090 DB19         TXLOOP:    IN       A,(PSIOAC)  ;CHECK STATUS
   93 0092 CB57                    BIT      2,A
   94 0094 28FA                    JR       Z,TXLOOP
   95 0096 F1                      POP      AF          ; TRANSFER
   96 0097 D318                    OUT      (PSIOAD),A
   97 0099 C9                      RET
   98                   ;
   99                   ;       CHECK RECEIVE STATUS
  100 009A 3A4380       KBHIT:     LD       A,(RBFCNT)
  101 009D FE00                    CP       00H
  102 009F C9                      RET
  103                   ;
  104                   ;       SIO COMMAND CHAIN
  105 00A0              SIOCMD:
  106 00A0 18                      DB       00011000B   ;RESET
  107 00A1 0444                    DB       04H,01000100B ;SERIAL
  108 00A3 0118                    DB       01H,00011000B ;INTERRUPT
  109 00A5 05EA                    DB       05H,11101010B ;TRANSMIT
  110 00A7 03C1                    DB       03H,11000001B ;RECEIVE
  111 0009              SIOCML     EQU      $-SIOCMD
  112                   ;
  113                   ;       SYSTEM INITIALIZE
  114 00A9 31ED80       SINIT:     LD       SP,TSTACK
  115 00AC 210080                  LD       HL,RECBUF
  116 00AF 223F80                  LD       (RBFWTP),HL
  117 00B2 224180                  LD       (RBFRDP),HL
  118 00B5 AF                      XOR      A
  119 00B6 324380                  LD       (RBFCNT),A
  120                   ;
  121                   ;       CTC INITIALIZE
  122 00B9 3E07                    LD       A,00000111B
  123 00BB D312                    OUT      (PCTCC2),A
  124                   ;       LD      A,4             ;9.8304MHz
  125                   ;       LD      A,3             ;7.3728MHz
  126                   ;       LD      A,2             ;4.9152MHz
  127 00BD 3E01                    LD       A,1         ;2.4576MHz
  128 00BF D312                    OUT      (PCTCC2),A
  129                   ;
  130                   ;       SIO INITIALIZE
  131 00C1 0609                    LD       B,SIOCML
  132 00C3 0E19                    LD       C,PSIOAC
  133 00C5 21A000                  LD       HL,SIOCMD
  134 00C8 EDB3                    OTIR
  135                   ;
  136                   ;       SETUP INTERRUPT
  137 00CA ED56                    IM       1
  138 00CC FB                      EI
  139                   ;
  140                   ;       START BASIC
  141 00CD C3D000                  JP       COLD
  142                   ;
  143                   ;======================================================
  144                   ; The updates to the original BASIC within this file ar
  145                   ;
  146                   ; You have permission to use this for NON COMMERCIAL US
  147                   ; If you wish to use it elsewhere, please include an ac
  148                   ;
  149                   ; http://searle.hostei.com/grant/index.html
  150                   ;
  151                   ; eMail: home.micros01@btinternet.com
  152                   ;
  153                   ; If the above don't work, please perform an Internet s
  154                   ; updated the web page hosting service.
  155                   ;
  156                   ;======================================================
  157                   ;
  158                   ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  159                   ; Scanned from source published in 80-BUS NEWS from Vol
  160                   ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  161                   ; Adapted for the freeware Zilog Macro Assembler 2.10 t
  162                   ; the original ROM code (checksum A934H). PA
  163                   ;
  164                   ; GENERAL EQUATES
  165                   ;
  166 0003              CTRLC      EQU      03H         ; Control "C"
  167 0007              CTRLG      EQU      07H         ; Control "G"
  168 0008              BKSP       EQU      08H         ; Back space
  169 000A              LF         EQU      0AH         ; Line feed
  170 000C              CS         EQU      0CH         ; Clear screen
  171 000D              CR         EQU      0DH         ; Carriage return
  172 000F              CTRLO      EQU      0FH         ; Control "O"
  173 0011              CTRLQ      EQU      11H         ; Control "Q"
  174 0012              CTRLR      EQU      12H         ; Control "R"
  175 0013              CTRLS      EQU      13H         ; Control "S"
  176 0015              CTRLU      EQU      15H         ; Control "U"
  177 001B              ESC        EQU      1BH         ; Escape
  178 007F              DEL        EQU      7FH         ; Delete
  179                   ;
  180                   ; BASIC WORK SPACE LOCATIONS
  181                   ;
  182 8045              WRKSPC     EQU      8045H       ; BASIC Work space
  183 8048              USR        EQU      WRKSPC+3H   ; "USR (x)" jump
  184 804B              OUTSUB     EQU      WRKSPC+6H   ; "OUT p,n"
  185 804C              OTPORT     EQU      WRKSPC+7H   ; Port (p)
  186 804E              DIVSUP     EQU      WRKSPC+9H   ; Division support rout
  187 804F              DIV1       EQU      WRKSPC+0AH  ; <- Values
  188 8053              DIV2       EQU      WRKSPC+0EH  ; <- to
  189 8057              DIV3       EQU      WRKSPC+12H  ; <- be
  190 805A              DIV4       EQU      WRKSPC+15H  ; <- inserted
  191 805C              SEED       EQU      WRKSPC+17H  ; Random number seed
  192 807F              LSTRND     EQU      WRKSPC+3AH  ; Last random number
  193 8083              INPSUB     EQU      WRKSPC+3EH  ; #INP (x)" Routine
  194 8084              INPORT     EQU      WRKSPC+3FH  ; PORT (x)
  195 8086              NULLS      EQU      WRKSPC+41H  ; Number of nulls
  196 8087              LWIDTH     EQU      WRKSPC+42H  ; Terminal width
  197 8088              COMMAN     EQU      WRKSPC+43H  ; Width for commas
  198 8089              NULFLG     EQU      WRKSPC+44H  ; Null after input byte
  199 808A              CTLOFG     EQU      WRKSPC+45H  ; Control "O" flag
  200 808B              LINESC     EQU      WRKSPC+46H  ; Lines counter
  201 808D              LINESN     EQU      WRKSPC+48H  ; Lines number
  202 808F              CHKSUM     EQU      WRKSPC+4AH  ; Array load/save check
  203 8091              NMIFLG     EQU      WRKSPC+4CH  ; Flag for NMI break ro
  204 8092              BRKFLG     EQU      WRKSPC+4DH  ; Break flag
  205 8093              RINPUT     EQU      WRKSPC+4EH  ; Input reflection
  206 8096              POINT      EQU      WRKSPC+51H  ; "POINT" reflection (u
  207 8099              PSET       EQU      WRKSPC+54H  ; "SET" reflection
  208 809C              RESET      EQU      WRKSPC+57H  ; "RESET" reflection
  209 809F              STRSPC     EQU      WRKSPC+5AH  ; Bottom of string spac
  210 80A1              LINEAT     EQU      WRKSPC+5CH  ; Current line number
  211 80A3              BASTXT     EQU      WRKSPC+5EH  ; Pointer to start of p
  212 80A6              BUFFER     EQU      WRKSPC+61H  ; Input buffer
  213 80AB              STACK      EQU      WRKSPC+66H  ; Initial stack
  214 80F0              CURPOS     EQU      WRKSPC+0ABH ; Character position on
  215 80F1              LCRFLG     EQU      WRKSPC+0ACH ; Locate/Create flag
  216 80F2              TYPE       EQU      WRKSPC+0ADH ; Data type flag
  217 80F3              DATFLG     EQU      WRKSPC+0AEH ; Literal statement fla
  218 80F4              LSTRAM     EQU      WRKSPC+0AFH ; Last available RAM
  219 80F6              TMSTPT     EQU      WRKSPC+0B1H ; Temporary string poin
  220 80F8              TMSTPL     EQU      WRKSPC+0B3H ; Temporary string pool
  221 8104              TMPSTR     EQU      WRKSPC+0BFH ; Temporary string
  222 8108              STRBOT     EQU      WRKSPC+0C3H ; Bottom of string spac
  223 810A              CUROPR     EQU      WRKSPC+0C5H ; Current operator in E
  224 810C              LOOPST     EQU      WRKSPC+0C7H ; First statement of lo
  225 810E              DATLIN     EQU      WRKSPC+0C9H ; Line of current DATA 
  226 8110              FORFLG     EQU      WRKSPC+0CBH ; "FOR" loop flag
  227 8111              LSTBIN     EQU      WRKSPC+0CCH ; Last byte entered
  228 8112              READFG     EQU      WRKSPC+0CDH ; Read/Input flag
  229 8113              BRKLIN     EQU      WRKSPC+0CEH ; Line of break
  230 8115              NXTOPR     EQU      WRKSPC+0D0H ; Next operator in EVAL
  231 8117              ERRLIN     EQU      WRKSPC+0D2H ; Line of error
  232 8119              CONTAD     EQU      WRKSPC+0D4H ; Where to CONTinue
  233 811B              PROGND     EQU      WRKSPC+0D6H ; End of program
  234 811D              VAREND     EQU      WRKSPC+0D8H ; End of variables
  235 811F              ARREND     EQU      WRKSPC+0DAH ; End of arrays
  236 8121              NXTDAT     EQU      WRKSPC+0DCH ; Next data item
  237 8123              FNRGNM     EQU      WRKSPC+0DEH ; Name of FN argument
  238 8125              FNARG      EQU      WRKSPC+0E0H ; FN argument value
  239 8129              FPREG      EQU      WRKSPC+0E4H ; Floating point regist
  240 812C              FPEXP      EQU      FPREG+3     ; Floating point expone
  241 812D              SGNRES     EQU      WRKSPC+0E8H ; Sign of result
  242 812E              PBUFF      EQU      WRKSPC+0E9H ; Number print buffer
  243 813B              MULVAL     EQU      WRKSPC+0F6H ; Multiplier
  244 813E              PROGST     EQU      WRKSPC+0F9H ; Start of program text
  245 81A2              STLOOK     EQU      WRKSPC+15DH ; Start of memory test
  246                   ;
  247                   ; BASIC ERROR CODE VALUES
  248                   ;
  249 0000              NF         EQU      00H         ; NEXT without FOR
  250 0002              SN         EQU      02H         ; Syntax error
  251 0004              RG         EQU      04H         ; RETURN without GOSUB
  252 0006              OD         EQU      06H         ; Out of DATA
  253 0008              FC         EQU      08H         ; Function call error
  254 000A              OV         EQU      0AH         ; Overflow
  255 000C              OM         EQU      0CH         ; Out of memory
  256 000E              UL         EQU      0EH         ; Undefined line number
  257 0010              BS         EQU      10H         ; Bad subscript
  258 0012              RD         EQU      12H         ; Re-DIMensioned array
  259 0014              DZ         EQU      14H         ; Division by zero (/0)
  260 0016              ID         EQU      16H         ; Illegal direct
  261 0018              TM         EQU      18H         ; Type miss-match
  262 001A              OS         EQU      1AH         ; Out of string space
  263 001C              LS         EQU      1CH         ; String too long
  264 001E              ST         EQU      1EH         ; String formula too co
  265 0020              CN         EQU      20H         ; Can't CONTinue
  266 0022              UF         EQU      22H         ; UnDEFined FN function
  267 0024              MO         EQU      24H         ; Missing operand
  268 0026              HX         EQU      26H         ; HEX error
  269 0028              BN         EQU      28H         ; BIN error
  270                   ;
  271 00D0 C3D600       COLD:      JP       STARTB      ; Jump for cold start
  272 00D3 C34B01       WARM:      JP       WARMST      ; Jump for warm start
  273 00D6 C3DD00       STARTB:    JP       CSTART      ; Jump to initialise
  274                   ;
  275 00D9 8E09                    DW       DEINT       ; Get integer -32768 to
  276 00DB 0411                    DW       ABPASS      ; Return integer in AB
  277                   ;
  278 00DD 214580       CSTART:    LD       HL,WRKSPC   ; Start of workspace RA
  279 00E0 F9                      LD       SP,HL       ; Set up a temporary st
  280 00E1 C31F1D                  JP       INITST      ; Go to initialise
  281                   ;
  282 00E4 11B503       INIT:      LD       DE,INITAB   ; Initialise workspace
  283 00E7 0663                    LD       B,INITBE-INITAB+3 ; Bytes to copy
  284 00E9 214580                  LD       HL,WRKSPC   ; Into workspace RAM
  285 00EC 1A           COPY:      LD       A,(DE)      ; Get source
  286 00ED 77                      LD       (HL),A      ; To destination
  287 00EE 23                      INC      HL          ; Next destination
  288 00EF 13                      INC      DE          ; Next source
  289 00F0 05                      DEC      B           ; Count bytes
  290 00F1 C2EC00                  JP       NZ,COPY     ; More to move
  291 00F4 F9                      LD       SP,HL       ; Temporary stack
  292 00F5 CDB605                  CALL     CLREG       ; Clear registers and s
  293 00F8 CD840B                  CALL     PRCRLF      ; Output CRLF
  294 00FB 32EF80                  LD       (BUFFER+72+1),A ; Mark end of buffe
  295 00FE 323E81                  LD       (PROGST),A  ; Initialise program ar
  296 0101 21A281       MSIZE:     LD       HL,STLOOK   ; Point to start of RAM
  297 0104 23           MLOOP:     INC      HL          ; Next byte
  298 0105 7C                      LD       A,H         ; Above address FFFF ?
  299 0106 B5                      OR       L
  300 0107 CA1301                  JP       Z,SETTOP    ; Yes - 64K RAM
  301 010A 7E                      LD       A,(HL)      ; Get contents
  302 010B 47                      LD       B,A         ; Save it
  303 010C 2F                      CPL                  ; Flip all bits
  304 010D 77                      LD       (HL),A      ; Put it back
  305 010E BE                      CP       (HL)        ; RAM there if same
  306 010F 70                      LD       (HL),B      ; Restore old contents
  307 0110 CA0401                  JP       Z,MLOOP     ; If RAM - test next by
  308                   ;
  309 0113 2B           SETTOP:    DEC      HL          ; Back one byte
  310 0114 11A181                  LD       DE,STLOOK-1 ; See if enough RAM
  311 0117 CD4C07                  CALL     CPDEHL      ; Compare DE with HL
  312 011A DA5401                  JP       C,NEMEM     ; If not enough RAM
  313 011D 11CEFF                  LD       DE,0-50     ; 50 Bytes string space
  314 0120 22F480                  LD       (LSTRAM),HL ; Save last available R
  315 0123 19                      ADD      HL,DE       ; Allocate string space
  316 0124 229F80                  LD       (STRSPC),HL ; Save string space
  317 0127 CD9105                  CALL     CLRPTR      ; Clear program area
  318 012A 2A9F80                  LD       HL,(STRSPC) ; Get end of memory
  319 012D 11EFFF                  LD       DE,0-17     ; Offset for free bytes
  320 0130 19                      ADD      HL,DE       ; Adjust HL
  321 0131 113E81                  LD       DE,PROGST   ; Start of program text
  322 0134 7D                      LD       A,L         ; Get LSB
  323 0135 93                      SUB      E           ; Adjust it
  324 0136 6F                      LD       L,A         ; Re-save
  325 0137 7C                      LD       A,H         ; Get MSB
  326 0138 9A                      SBC      A,D         ; Adjust it
  327 0139 67                      LD       H,A         ; Re-save
  328 013A E5                      PUSH     HL          ; Save bytes free
  329 013B 216C01                  LD       HL,SIGNON   ; Sign-on message
  330 013E CD2212                  CALL     PRS         ; Output string
  331 0141 E1                      POP      HL          ; Get bytes free back
  332 0142 CDC518                  CALL     PRNTHL      ; Output amount of free
  333 0145 215D01                  LD       HL,BFREE    ; " Bytes free" message
  334 0148 CD2212                  CALL     PRS         ; Output string
  335                   ;
  336 014B 31AB80       WARMST:    LD       SP,STACK    ; Temporary stack
  337 014E CDB605       BRKRET:    CALL     CLREG       ; Clear registers and s
  338 0151 C3CF04                  JP       PRNTOK      ; Go to get command lin
  339                   ;
  340 0154 21A301       NEMEM:     LD       HL,MEMMSG   ; Memory size not enoug
  341 0157 CD2212                  CALL     PRS         ; Print it
  342 015A C35A01       XXXXX:     JP       XXXXX       ; Stop
  343                   ;
  344 015D 204279746573 BFREE:     DB       " Bytes free",CR,LF,0,0
           20667265650D 
           0A0000       
  345                   ;
  346 016C 5A3830204241 SIGNON:    DB       "Z80 BASIC Ver 4.7b",CR,LF
           534943205665 
           7220342E3762 
           0D0A         
  347 0180 436F70797269            DB       "Copyright ",40,"C",41
           676874202843 
           29           
  348 018D 203139373820            DB       " 1978 by Microsoft",CR,LF,0,0
           6279204D6963 
           726F736F6674 
           0D0A0000     
  349                   ;
  350 01A3 4D656D6F7279 MEMMSG:    DB       "Memory size not enough",CR,LF
           2073697A6520 
           6E6F7420656E 
           6F7567680D0A 
  351 01BB 546865207379            DB       "The system is stopped.",CR,LF,0,0
           7374656D2069 
           732073746F70 
           7065642E0D0A 
           0000         
  352                   ;
  353                   ; FUNCTION ADDRESS TABLE
  354                   ;
  355 01D5 3A17         FNCTAB:    DW       SGN
  356 01D7 FE17                    DW       INT
  357 01D9 5017                    DW       ABS
  358 01DB 4880                    DW       USR
  359 01DD E210                    DW       FRE
  360 01DF 6714                    DW       INP
  361 01E1 1011                    DW       POS
  362 01E3 C419                    DW       SQR
  363 01E5 A31A                    DW       RND
  364 01E7 DF15                    DW       LOG
  365 01E9 121A                    DW       EXP
  366 01EB 181B                    DW       COS
  367 01ED 1E1B                    DW       SIN
  368 01EF 7F1B                    DW       TAN
  369 01F1 941B                    DW       ATN
  370 01F3 BB14                    DW       PEEK
  371 01F5 FF1B                    DW       DEEK
  372 01F7 9680                    DW       POINT
  373 01F9 9413                    DW       LEN
  374 01FB AC11                    DW       STR
  375 01FD 2E14                    DW       VAL
  376 01FF A313                    DW       ASC
  377 0201 B413                    DW       CHR
  378 0203 211C                    DW       HEX
  379 0205 B41C                    DW       BIN
  380 0207 C413                    DW       LEFT
  381 0209 F413                    DW       RIGHT
  382 020B FE13                    DW       MID
  383                   ;
  384                   ; RESERVED WORD LIST
  385                   ;
  386 020D C54E44       WORDS:     DB       0C5H,"ND"
  387 0210 C64F52                  DB       0C6H,"OR"
  388 0213 CE455854                DB       0CEH,"EXT"
  389 0217 C4415441                DB       0C4H,"ATA"
  390 021B C94E505554              DB       0C9H,"NPUT"
  391 0220 C4494D                  DB       0C4H,"IM"
  392 0223 D2454144                DB       0D2H,"EAD"
  393 0227 CC4554                  DB       0CCH,"ET"
  394 022A C74F544F                DB       0C7H,"OTO"
  395 022E D2554E                  DB       0D2H,"UN"
  396 0231 C946                    DB       0C9H,"F"
  397 0233 D24553544F52            DB       0D2H,"ESTORE"
           45           
  398 023A C74F535542              DB       0C7H,"OSUB"
  399 023F D2455455524E            DB       0D2H,"ETURN"
  400 0245 D2454D                  DB       0D2H,"EM"
  401 0248 D3544F50                DB       0D3H,"TOP"
  402 024C CF5554                  DB       0CFH,"UT"
  403 024F CF4E                    DB       0CFH,"N"
  404 0251 CE554C4C                DB       0CEH,"ULL"
  405 0255 D7414954                DB       0D7H,"AIT"
  406 0259 C44546                  DB       0C4H,"EF"
  407 025C D04F4B45                DB       0D0H,"OKE"
  408 0260 C44F4B45                DB       0C4H,"OKE"
  409 0264 D3435245454E            DB       0D3H,"CREEN"
  410 026A CC494E4553              DB       0CCH,"INES"
  411 026F C34C53                  DB       0C3H,"LS"
  412 0272 D749445448              DB       0D7H,"IDTH"
  413 0277 CD4F4E49544F            DB       0CDH,"ONITOR"
           52           
  414 027E D34554                  DB       0D3H,"ET"
  415 0281 D245534554              DB       0D2H,"ESET"
  416 0286 D052494E54              DB       0D0H,"RINT"
  417 028B C34F4E54                DB       0C3H,"ONT"
  418 028F CC495354                DB       0CCH,"IST"
  419 0293 C34C454152              DB       0C3H,"LEAR"
  420 0298 C34C4F4144              DB       0C3H,"LOAD"
  421 029D C353415645              DB       0C3H,"SAVE"
  422 02A2 CE4557                  DB       0CEH,"EW"
  423                   ;
  424 02A5 D4414228                DB       0D4H,"AB("
  425 02A9 D44F                    DB       0D4H,"O"
  426 02AB C64E                    DB       0C6H,"N"
  427 02AD D3504328                DB       0D3H,"PC("
  428 02B1 D448454E                DB       0D4H,"HEN"
  429 02B5 CE4F54                  DB       0CEH,"OT"
  430 02B8 D3544550                DB       0D3H,"TEP"
  431                   ;
  432 02BC AB                      DB       0ABH
  433 02BD AD                      DB       0ADH
  434 02BE AA                      DB       0AAH
  435 02BF AF                      DB       0AFH
  436 02C0 DE                      DB       0DEH
  437 02C1 C14E44                  DB       0C1H,"ND"
  438 02C4 CF52                    DB       0CFH,"R"
  439 02C6 BE                      DB       0BEH
  440 02C7 BD                      DB       0BDH
  441 02C8 BC                      DB       0BCH
  442                   ;
  443 02C9 D3474E                  DB       0D3H,"GN"
  444 02CC C94E54                  DB       0C9H,"NT"
  445 02CF C14253                  DB       0C1H,"BS"
  446 02D2 D55352                  DB       0D5H,"SR"
  447 02D5 C65245                  DB       0C6H,"RE"
  448 02D8 C94E50                  DB       0C9H,"NP"
  449 02DB D04F53                  DB       0D0H,"OS"
  450 02DE D35152                  DB       0D3H,"QR"
  451 02E1 D24E44                  DB       0D2H,"ND"
  452 02E4 CC4F47                  DB       0CCH,"OG"
  453 02E7 C55850                  DB       0C5H,"XP"
  454 02EA C34F53                  DB       0C3H,"OS"
  455 02ED D3494E                  DB       0D3H,"IN"
  456 02F0 D4414E                  DB       0D4H,"AN"
  457 02F3 C1544E                  DB       0C1H,"TN"
  458 02F6 D045454B                DB       0D0H,"EEK"
  459 02FA C445454B                DB       0C4H,"EEK"
  460 02FE D04F494E54              DB       0D0H,"OINT"
  461 0303 CC454E                  DB       0CCH,"EN"
  462 0306 D3545224                DB       0D3H,"TR$"
  463 030A D6414C                  DB       0D6H,"AL"
  464 030D C15343                  DB       0C1H,"SC"
  465 0310 C3485224                DB       0C3H,"HR$"
  466 0314 C8455824                DB       0C8H,"EX$"
  467 0318 C2494E24                DB       0C2H,"IN$"
  468 031C CC45465424              DB       0CCH,"EFT$"
  469 0321 D24947485424            DB       0D2H,"IGHT$"
  470 0327 CD494424                DB       0CDH,"ID$"
  471 032B 80                      DB       80H         ; End of list marker
  472                   ;
  473                   ; KEYWORD ADDRESS TABLE
  474                   ;
  475 032C 2609         WORDTB:    DW       PEND
  476 032E 2308                    DW       FOR
  477 0330 FE0C                    DW       NEXT
  478 0332 730A                    DW       DATA
  479 0334 050C                    DW       INPUT
  480 0336 3A0F                    DW       DIM
  481 0338 340C                    DW       READ
  482 033A 8A0A                    DW       LET
  483 033C 300A                    DW       GOTO
  484 033E 130A                    DW       RUN
  485 0340 020B                    DW       IF
  486 0342 EC08                    DW       RESTOR
  487 0344 1F0A                    DW       GOSUB
  488 0346 4E0A                    DW       RETURN
  489 0348 750A                    DW       REM
  490 034A 2409                    DW       STOP
  491 034C 7314                    DW       POUT
  492 034E E40A                    DW       ON
  493 0350 6509                    DW       NULL
  494 0352 7914                    DW       WAIT
  495 0354 1811                    DW       DEF
  496 0356 C214                    DW       POKE
  497 0358 0A1C                    DW       DOKE
  498 035A 750A                    DW       REM
  499 035C F01B                    DW       LINES
  500 035E E31B                    DW       CLS
  501 0360 E81B                    DW       WIDTH
  502 0362 1C1D                    DW       MONITR
  503 0364 9980                    DW       PSET
  504 0366 9C80                    DW       RESET
  505 0368 260B                    DW       PRINT
  506 036A 5209                    DW       CONT
  507 036C 9807                    DW       LIST
  508 036E CD09                    DW       CLEAR
  509 0370 750A                    DW       REM
  510 0372 750A                    DW       REM
  511 0374 9005                    DW       NEW
  512                   ;
  513                   ; RESERVED WORD TOKEN VALUES
  514                   ;
  515 0080              ZEND       EQU      080H        ; END
  516 0081              ZFOR       EQU      081H        ; FOR
  517 0083              ZDATA      EQU      083H        ; DATA
  518 0088              ZGOTO      EQU      088H        ; GOTO
  519 008C              ZGOSUB     EQU      08CH        ; GOSUB
  520 008E              ZREM       EQU      08EH        ; REM
  521 009E              ZPRINT     EQU      09EH        ; PRINT
  522 00A4              ZNEW       EQU      0A4H        ; NEW
  523                   ;
  524 00A5              ZTAB       EQU      0A5H        ; TAB
  525 00A6              ZTO        EQU      0A6H        ; TO
  526 00A7              ZFN        EQU      0A7H        ; FN
  527 00A8              ZSPC       EQU      0A8H        ; SPC
  528 00A9              ZTHEN      EQU      0A9H        ; THEN
  529 00AA              ZNOT       EQU      0AAH        ; NOT
  530 00AB              ZSTEP      EQU      0ABH        ; STEP
  531                   ;
  532 00AC              ZPLUS      EQU      0ACH        ; +
  533 00AD              ZMINUS     EQU      0ADH        ; -
  534 00AE              ZTIMES     EQU      0AEH        ; *
  535 00AF              ZDIV       EQU      0AFH        ; /
  536 00B2              ZOR        EQU      0B2H        ; OR
  537 00B3              ZGTR       EQU      0B3H        ; >
  538 00B4              ZEQUAL     EQU      0B4H        ; M
  539 00B5              ZLTH       EQU      0B5H        ; <
  540 00B6              ZSGN       EQU      0B6H        ; SGN
  541 00C7              ZPOINT     EQU      0C7H        ; POINT
  542 00CF              ZLEFT      EQU      0CDH +2     ; LEFT$
  543                   ;
  544                   ; ARITHMETIC PRECEDENCE TABLE
  545                   ;
  546 0376 79           PRITAB:    DB       79H         ; Precedence value
  547 0377 AC18                    DW       PADD        ; FPREG = <last> + FPRE
  548                   ;
  549 0379 79                      DB       79H         ; Precedence value
  550 037A E014                    DW       PSUB        ; FPREG = <last> - FPRE
  551                   ;
  552 037C 7C                      DB       7CH         ; Precedence value
  553 037D 1E16                    DW       MULT        ; PPREG = <last> * FPRE
  554                   ;
  555 037F 7C                      DB       7CH         ; Precedence value
  556 0380 7F16                    DW       DIV         ; FPREG = <last> / FPRE
  557                   ;
  558 0382 7F                      DB       7FH         ; Precedence value
  559 0383 CD19                    DW       POWER       ; FPREG = <last> ^ FPRE
  560                   ;
  561 0385 50                      DB       50H         ; Precedence value
  562 0386 930E                    DW       PAND        ; FPREG = <last> AND FP
  563                   ;
  564 0388 46                      DB       46H         ; Precedence value
  565 0389 920E                    DW       POR         ; FPREG = <last> OR FPR
  566                   ;
  567                   ; BASIC ERROR CODE LIST
  568                   ;
  569 038B 4E46         ERRORS:    DB       "NF"        ; NEXT without FOR
  570 038D 534E                    DB       "SN"        ; Syntax error
  571 038F 5247                    DB       "RG"        ; RETURN without GOSUB
  572 0391 4F44                    DB       "OD"        ; Out of DATA
  573 0393 4643                    DB       "FC"        ; Illegal function call
  574 0395 4F56                    DB       "OV"        ; Overflow error
  575 0397 4F4D                    DB       "OM"        ; Out of memory
  576 0399 554C                    DB       "UL"        ; Undefined line
  577 039B 4253                    DB       "BS"        ; Bad subscript
  578 039D 4444                    DB       "DD"        ; Re-DIMensioned array
  579 039F 2F30                    DB       "/0"        ; Division by zero
  580 03A1 4944                    DB       "ID"        ; Illegal direct
  581 03A3 544D                    DB       "TM"        ; Type mis-match
  582 03A5 4F53                    DB       "OS"        ; Out of string space
  583 03A7 4C53                    DB       "LS"        ; String too long
  584 03A9 5354                    DB       "ST"        ; String formula too co
  585 03AB 434E                    DB       "CN"        ; Can't CONTinue
  586 03AD 5546                    DB       "UF"        ; Undefined FN function
  587 03AF 4D4F                    DB       "MO"        ; Missing operand
  588 03B1 4858                    DB       "HX"        ; HEX error
  589 03B3 424E                    DB       "BN"        ; BIN error
  590                   ;
  591                   ; INITIALISATION TABLE --------------------------------
  592                   ;
  593 03B5 C34B01       INITAB:    JP       WARMST      ; Warm start jump
  594 03B8 C3A309                  JP       FCERR       ; "USR (X)" jump (Set t
  595 03BB D300                    OUT      (0),A       ; "OUT p,n" skeleton
  596 03BD C9                      RET
  597 03BE D600                    SUB      0           ; Division support rout
  598 03C0 6F                      LD       L,A
  599 03C1 7C                      LD       A,H
  600 03C2 DE00                    SBC      A,0
  601 03C4 67                      LD       H,A
  602 03C5 78                      LD       A,B
  603 03C6 DE00                    SBC      A,0
  604 03C8 47                      LD       B,A
  605 03C9 3E00                    LD       A,0
  606 03CB C9                      RET
  607 03CC 000000                  DB       0,0,0       ; Random number seed ta
  608 03CF 354ACA99                DB       035H,04AH,0CAH,099H ;-2.65145E+07
  609 03D3 391C7698                DB       039H,01CH,076H,098H ; 1.61291E+07
  610 03D7 2295B398                DB       022H,095H,0B3H,098H ;-1.17691E+07
  611 03DB 0ADD4798                DB       00AH,0DDH,047H,098H ; 1.30983E+07
  612 03DF 53D19999                DB       053H,0D1H,099H,099H ;-2-01612E+07
  613 03E3 0A1A9F98                DB       00AH,01AH,09FH,098H ;-1.04269E+07
  614 03E7 65BCCD98                DB       065H,0BCH,0CDH,098H ;-1.34831E+07
  615 03EB D6773E98                DB       0D6H,077H,03EH,098H ; 1.24825E+07
  616 03EF 52C74F80                DB       052H,0C7H,04FH,080H ; Last random n
  617 03F3 DB00                    IN       A,(0)       ; INP (x) skeleton
  618 03F5 C9                      RET
  619 03F6 01                      DB       1           ; POS (x) number (1)
  620 03F7 FF                      DB       255         ; Terminal width (255 =
  621 03F8 1C                      DB       28          ; Width for commas (3 c
  622 03F9 00                      DB       0           ; No nulls after input 
  623 03FA 00                      DB       0           ; Output enabled (^O of
  624 03FB 1400                    DW       20          ; Initial lines counter
  625 03FD 1400                    DW       20          ; Initial lines number
  626 03FF 0000                    DW       0           ; Array load/save check
  627 0401 00                      DB       0           ; Break not by NMI
  628 0402 00                      DB       0           ; Break flag
  629 0403 C3C906                  JP       TTYLIN      ; Input reflection (set
  630 0406 C30000                  JP       0000H       ; POINT reflection unus
  631 0409 C30000                  JP       0000H       ; SET reflection
  632 040C C30000                  JP       0000H       ; RESET reflection
  633 040F A281                    DW       STLOOK      ; Temp string space
  634 0411 FEFF                    DW       -2          ; Current line number (
  635 0413 3F81                    DW       PROGST+1    ; Start of program text
  636 0415              INITBE:
  637                   ;
  638                   ; END OF INITIALISATION TABLE -------------------------
  639                   ;
  640 0415 204572726F72 ERRMSG:    DB       " Error",0
           00           
  641 041C 20696E2000   INMSG:     DB       " in ",0
  642 0420              ZERBYT     EQU      $-1         ; A zero byte
  643 0421 4F6B0D0A0000 OKMSG:     DB       "Ok",CR,LF,0,0
  644 0427 427265616B00 BRKMSG:    DB       "Break",0
  645                   ;
  646 042D 210400       BAKSTK:    LD       HL,4        ; Look for "FOR" block 
  647 0430 39                      ADD      HL,SP       ; same index as specifi
  648 0431 7E           LOKFOR:    LD       A,(HL)      ; Get block ID
  649 0432 23                      INC      HL          ; Point to index addres
  650 0433 FE81                    CP       ZFOR        ; Is it a "FOR" token
  651 0435 C0                      RET      NZ          ; No - exit
  652 0436 4E                      LD       C,(HL)      ; BC = Address of "FOR"
  653 0437 23                      INC      HL
  654 0438 46                      LD       B,(HL)
  655 0439 23                      INC      HL          ; Point to sign of STEP
  656 043A E5                      PUSH     HL          ; Save pointer to sign
  657 043B 69                      LD       L,C         ; HL = address of "FOR"
  658 043C 60                      LD       H,B
  659 043D 7A                      LD       A,D         ; See if an index was s
  660 043E B3                      OR       E           ; DE = 0 if no index sp
  661 043F EB                      EX       DE,HL       ; Specified index into 
  662 0440 CA4704                  JP       Z,INDFND    ; Skip if no index give
  663 0443 EB                      EX       DE,HL       ; Index back into DE
  664 0444 CD4C07                  CALL     CPDEHL      ; Compare index with on
  665 0447 010D00       INDFND:    LD       BC,16-3     ; Offset to next block
  666 044A E1                      POP      HL          ; Restore pointer to si
  667 044B C8                      RET      Z           ; Return if block found
  668 044C 09                      ADD      HL,BC       ; Point to next block
  669 044D C33104                  JP       LOKFOR      ; Keep on looking
  670                   ;
  671 0450 CD6A04       MOVUP:     CALL     ENFMEM      ; See if enough memory
  672 0453 C5           MOVSTR:    PUSH     BC          ; Save end of source
  673 0454 E3                      EX       (SP),HL     ; Swap source and dest"
  674 0455 C1                      POP      BC          ; Get end of destinatio
  675 0456 CD4C07       MOVLP:     CALL     CPDEHL      ; See if list moved
  676 0459 7E                      LD       A,(HL)      ; Get byte
  677 045A 02                      LD       (BC),A      ; Move it
  678 045B C8                      RET      Z           ; Exit if all done
  679 045C 0B                      DEC      BC          ; Next byte to move to
  680 045D 2B                      DEC      HL          ; Next byte to move
  681 045E C35604                  JP       MOVLP       ; Loop until all bytes 
  682                   ;
  683 0461 E5           CHKSTK:    PUSH     HL          ; Save code string addr
  684 0462 2A1F81                  LD       HL,(ARREND) ; Lowest free memory
  685 0465 0600                    LD       B,0         ; BC = Number of levels
  686 0467 09                      ADD      HL,BC       ; 2 Bytes for each leve
  687 0468 09                      ADD      HL,BC
  688 0469 3E                      DB       3EH         ; Skip "PUSH HL"
  689 046A E5           ENFMEM:    PUSH     HL          ; Save code string addr
  690 046B 3ED0                    LD       A,0D0H      ; LOW -48; 48 Bytes min
  691 046D 95                      SUB      L
  692 046E 6F                      LD       L,A
  693 046F 3EFF                    LD       A,0FFH      ; HIGH (-48); 48 Bytes 
  694 0471 9C                      SBC      A,H
  695 0472 DA7904                  JP       C,OMERR     ; Not enough - ?OM Erro
  696 0475 67                      LD       H,A
  697 0476 39                      ADD      HL,SP       ; Test if stack is over
  698 0477 E1                      POP      HL          ; Restore code string a
  699 0478 D8                      RET      C           ; Return if enough mmor
  700 0479 1E0C         OMERR:     LD       E,OM        ; ?OM Error
  701 047B C39804                  JP       ERROR
  702                   ;
  703 047E 2A0E81       DATSNR:    LD       HL,(DATLIN) ; Get line of current D
  704 0481 22A180                  LD       (LINEAT),HL ; Save as current line
  705 0484 1E02         SNERR:     LD       E,SN        ; ?SN Error
  706 0486 01                      DB       01H         ; Skip "LD E,DZ"
  707 0487 1E14         DZERR:     LD       E,DZ        ; ?/0 Error
  708 0489 01                      DB       01H         ; Skip "LD E,NF"
  709 048A 1E00         NFERR:     LD       E,NF        ; ?NF Error
  710 048C 01                      DB       01H         ; Skip "LD E,RD"
  711 048D 1E12         DDERR:     LD       E,RD        ; ?DD Error
  712 048F 01                      DB       01H         ; Skip "LD E,UF"
  713 0490 1E22         UFERR:     LD       E,UF        ; ?UF Error
  714 0492 01                      DB       01H         ; Skip "LD E,OV
  715 0493 1E0A         OVERR:     LD       E,OV        ; ?OV Error
  716 0495 01                      DB       01H         ; Skip "LD E,TM"
  717 0496 1E18         TMERR:     LD       E,TM        ; ?TM Error
  718                   ;
  719 0498 CDB605       ERROR:     CALL     CLREG       ; Clear registers and s
  720 049B 328A80                  LD       (CTLOFG),A  ; Enable output (A is 0
  721 049E CD770B                  CALL     STTLIN      ; Start new line
  722 04A1 218B03                  LD       HL,ERRORS   ; Point to error codes
  723 04A4 57                      LD       D,A         ; D = 0 (A is 0)
  724 04A5 3E3F                    LD       A,'?'
  725 04A7 CD5D07                  CALL     OUTC        ; Output '?'
  726 04AA 19                      ADD      HL,DE       ; Offset to correct err
  727 04AB 7E                      LD       A,(HL)      ; First character
  728 04AC CD5D07                  CALL     OUTC        ; Output it
  729 04AF CDDC08                  CALL     GETCHR      ; Get next character
  730 04B2 CD5D07                  CALL     OUTC        ; Output it
  731 04B5 211504                  LD       HL,ERRMSG   ; "Error" message
  732 04B8 CD2212       ERRIN:     CALL     PRS         ; Output message
  733 04BB 2AA180                  LD       HL,(LINEAT) ; Get line of error
  734 04BE 11FEFF                  LD       DE,-2       ; Cold start error if -
  735 04C1 CD4C07                  CALL     CPDEHL      ; See if cold start err
  736 04C4 CADD00                  JP       Z,CSTART    ; Cold start error - Re
  737 04C7 7C                      LD       A,H         ; Was it a direct error
  738 04C8 A5                      AND      L           ; Line = -1 if direct e
  739 04C9 3C                      INC      A
  740 04CA C4BD18                  CALL     NZ,LINEIN   ; No - output line of e
  741 04CD 3E                      DB       3EH         ; Skip "POP BC"
  742 04CE C1           POPNOK:    POP      BC          ; Drop address in input
  743                   ;
  744 04CF AF           PRNTOK:    XOR      A           ; Output "Ok" and get c
  745 04D0 328A80                  LD       (CTLOFG),A  ; Enable output
  746 04D3 CD770B                  CALL     STTLIN      ; Start new line
  747 04D6 212104                  LD       HL,OKMSG    ; "Ok" message
  748 04D9 CD2212                  CALL     PRS         ; Output "Ok"
  749 04DC 21FFFF       GETCMD:    LD       HL,-1       ; Flag direct mode
  750 04DF 22A180                  LD       (LINEAT),HL ; Save as current line
  751 04E2 CDC906                  CALL     GETLIN      ; Get an input line
  752 04E5 DADC04                  JP       C,GETCMD    ; Get line again if bre
  753 04E8 CDDC08                  CALL     GETCHR      ; Get first character
  754 04EB 3C                      INC      A           ; Test if end of line
  755 04EC 3D                      DEC      A           ; Without affecting Car
  756 04ED CADC04                  JP       Z,GETCMD    ; Nothing entered - Get
  757 04F0 F5                      PUSH     AF          ; Save Carry status
  758 04F1 CDA809                  CALL     ATOH        ; Get line number into 
  759 04F4 D5                      PUSH     DE          ; Save line number
  760 04F5 CDE005                  CALL     CRUNCH      ; Tokenise rest of line
  761 04F8 47                      LD       B,A         ; Length of tokenised l
  762 04F9 D1                      POP      DE          ; Restore line number
  763 04FA F1                      POP      AF          ; Restore Carry
  764 04FB D2BC08                  JP       NC,EXCUTE   ; No line number - Dire
  765 04FE D5                      PUSH     DE          ; Save line number
  766 04FF C5                      PUSH     BC          ; Save length of tokeni
  767 0500 AF                      XOR      A
  768 0501 321181                  LD       (LSTBIN),A  ; Clear last byte input
  769 0504 CDDC08                  CALL     GETCHR      ; Get next character
  770 0507 B7                      OR       A           ; Set flags
  771 0508 F5                      PUSH     AF          ; And save them
  772 0509 CD7005                  CALL     SRCHLN      ; Search for line numbe
  773 050C DA1505                  JP       C,LINFND    ; Jump if line found
  774 050F F1                      POP      AF          ; Get status
  775 0510 F5                      PUSH     AF          ; And re-save
  776 0511 CA490A                  JP       Z,ULERR     ; Nothing after number 
  777 0514 B7                      OR       A           ; Clear Carry
  778 0515 C5           LINFND:    PUSH     BC          ; Save address of line 
  779 0516 D22C05                  JP       NC,INEWLN   ; Line not found - Inse
  780 0519 EB                      EX       DE,HL       ; Next line address in 
  781 051A 2A1B81                  LD       HL,(PROGND) ; End of program
  782 051D 1A           SFTPRG:    LD       A,(DE)      ; Shift rest of program
  783 051E 02                      LD       (BC),A
  784 051F 03                      INC      BC          ; Next destination
  785 0520 13                      INC      DE          ; Next source
  786 0521 CD4C07                  CALL     CPDEHL      ; All done?
  787 0524 C21D05                  JP       NZ,SFTPRG   ; More to do
  788 0527 60                      LD       H,B         ; HL - New end of progr
  789 0528 69                      LD       L,C
  790 0529 221B81                  LD       (PROGND),HL ; Update end of program
  791                   ;
  792 052C D1           INEWLN:    POP      DE          ; Get address of line,
  793 052D F1                      POP      AF          ; Get status
  794 052E CA5305                  JP       Z,SETPTR    ; No text - Set up poin
  795 0531 2A1B81                  LD       HL,(PROGND) ; Get end of program
  796 0534 E3                      EX       (SP),HL     ; Get length of input l
  797 0535 C1                      POP      BC          ; End of program to BC
  798 0536 09                      ADD      HL,BC       ; Find new end
  799 0537 E5                      PUSH     HL          ; Save new end
  800 0538 CD5004                  CALL     MOVUP       ; Make space for line
  801 053B E1                      POP      HL          ; Restore new end
  802 053C 221B81                  LD       (PROGND),HL ; Update end of program
  803 053F EB                      EX       DE,HL       ; Get line to move up i
  804 0540 74                      LD       (HL),H      ; Save MSB
  805 0541 D1                      POP      DE          ; Get new line number
  806 0542 23                      INC      HL          ; Skip pointer
  807 0543 23                      INC      HL
  808 0544 73                      LD       (HL),E      ; Save LSB of line numb
  809 0545 23                      INC      HL
  810 0546 72                      LD       (HL),D      ; Save MSB of line numb
  811 0547 23                      INC      HL          ; To first byte in line
  812 0548 11A680                  LD       DE,BUFFER   ; Copy buffer to progra
  813 054B 1A           MOVBUF:    LD       A,(DE)      ; Get source
  814 054C 77                      LD       (HL),A      ; Save destinations
  815 054D 23                      INC      HL          ; Next source
  816 054E 13                      INC      DE          ; Next destination
  817 054F B7                      OR       A           ; Done?
  818 0550 C24B05                  JP       NZ,MOVBUF   ; No - Repeat
  819 0553 CD9C05       SETPTR:    CALL     RUNFST      ; Set line pointers
  820 0556 23                      INC      HL          ; To LSB of pointer
  821 0557 EB                      EX       DE,HL       ; Address to DE
  822 0558 62           PTRLP:     LD       H,D         ; Address to HL
  823 0559 6B                      LD       L,E
  824 055A 7E                      LD       A,(HL)      ; Get LSB of pointer
  825 055B 23                      INC      HL          ; To MSB of pointer
  826 055C B6                      OR       (HL)        ; Compare with MSB poin
  827 055D CADC04                  JP       Z,GETCMD    ; Get command line if e
  828 0560 23                      INC      HL          ; To LSB of line number
  829 0561 23                      INC      HL          ; Skip line number
  830 0562 23                      INC      HL          ; Point to first byte i
  831 0563 AF                      XOR      A           ; Looking for 00 byte
  832 0564 BE           FNDEND:    CP       (HL)        ; Found end of line?
  833 0565 23                      INC      HL          ; Move to next byte
  834 0566 C26405                  JP       NZ,FNDEND   ; No - Keep looking
  835 0569 EB                      EX       DE,HL       ; Next line address to 
  836 056A 73                      LD       (HL),E      ; Save LSB of pointer
  837 056B 23                      INC      HL
  838 056C 72                      LD       (HL),D      ; Save MSB of pointer
  839 056D C35805                  JP       PTRLP       ; Do next line
  840                   ;
  841 0570 2AA380       SRCHLN:    LD       HL,(BASTXT) ; Start of program text
  842 0573 44           SRCHLP:    LD       B,H         ; BC = Address to look 
  843 0574 4D                      LD       C,L
  844 0575 7E                      LD       A,(HL)      ; Get address of next l
  845 0576 23                      INC      HL
  846 0577 B6                      OR       (HL)        ; End of program found?
  847 0578 2B                      DEC      HL
  848 0579 C8                      RET      Z           ; Yes - Line not found
  849 057A 23                      INC      HL
  850 057B 23                      INC      HL
  851 057C 7E                      LD       A,(HL)      ; Get LSB of line numbe
  852 057D 23                      INC      HL
  853 057E 66                      LD       H,(HL)      ; Get MSB of line numbe
  854 057F 6F                      LD       L,A
  855 0580 CD4C07                  CALL     CPDEHL      ; Compare with line in 
  856 0583 60                      LD       H,B         ; HL = Start of this li
  857 0584 69                      LD       L,C
  858 0585 7E                      LD       A,(HL)      ; Get LSB of next line 
  859 0586 23                      INC      HL
  860 0587 66                      LD       H,(HL)      ; Get MSB of next line 
  861 0588 6F                      LD       L,A         ; Next line to HL
  862 0589 3F                      CCF
  863 058A C8                      RET      Z           ; Lines found - Exit
  864 058B 3F                      CCF
  865 058C D0                      RET      NC          ; Line not found,at lin
  866 058D C37305                  JP       SRCHLP      ; Keep looking
  867                   ;
  868 0590 C0           NEW:       RET      NZ          ; Return if any more on
  869 0591 2AA380       CLRPTR:    LD       HL,(BASTXT) ; Point to start of pro
  870 0594 AF                      XOR      A           ; Set program area to e
  871 0595 77                      LD       (HL),A      ; Save LSB = 00
  872 0596 23                      INC      HL
  873 0597 77                      LD       (HL),A      ; Save MSB = 00
  874 0598 23                      INC      HL
  875 0599 221B81                  LD       (PROGND),HL ; Set program end
  876                   ;
  877 059C 2AA380       RUNFST:    LD       HL,(BASTXT) ; Clear all variables
  878 059F 2B                      DEC      HL
  879                   ;
  880 05A0 221381       INTVAR:    LD       (BRKLIN),HL ; Initialise RUN variab
  881 05A3 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
  882 05A6 220881                  LD       (STRBOT),HL ; Clear string space
  883 05A9 AF                      XOR      A
  884 05AA CDEC08                  CALL     RESTOR      ; Reset DATA pointers
  885 05AD 2A1B81                  LD       HL,(PROGND) ; Get end of program
  886 05B0 221D81                  LD       (VAREND),HL ; Clear variables
  887 05B3 221F81                  LD       (ARREND),HL ; Clear arrays
  888                   ;
  889 05B6 C1           CLREG:     POP      BC          ; Save return address
  890 05B7 2A9F80                  LD       HL,(STRSPC) ; Get end of working RA
  891 05BA F9                      LD       SP,HL       ; Set stack
  892 05BB 21F880                  LD       HL,TMSTPL   ; Temporary string pool
  893 05BE 22F680                  LD       (TMSTPT),HL ; Reset temporary strin
  894 05C1 AF                      XOR      A           ; A = 00
  895 05C2 6F                      LD       L,A         ; HL = 0000
  896 05C3 67                      LD       H,A
  897 05C4 221981                  LD       (CONTAD),HL ; No CONTinue
  898 05C7 321081                  LD       (FORFLG),A  ; Clear FOR flag
  899 05CA 222381                  LD       (FNRGNM),HL ; Clear FN argument
  900 05CD E5                      PUSH     HL          ; HL = 0000
  901 05CE C5                      PUSH     BC          ; Put back return
  902 05CF 2A1381       DOAGN:     LD       HL,(BRKLIN) ; Get address of code t
  903 05D2 C9                      RET                  ; Return to execution d
  904                   ;
  905 05D3 3E3F         PROMPT:    LD       A,'?'       ; '?'
  906 05D5 CD5D07                  CALL     OUTC        ; Output character
  907 05D8 3E20                    LD       A,' '       ; Space
  908 05DA CD5D07                  CALL     OUTC        ; Output character
  909 05DD C39380                  JP       RINPUT      ; Get input line
  910                   ;
  911 05E0 AF           CRUNCH:    XOR      A           ; Tokenise line @ HL to
  912 05E1 32F380                  LD       (DATFLG),A  ; Reset literal flag
  913 05E4 0E05                    LD       C,2+3       ; 2 byte number and 3 n
  914 05E6 11A680                  LD       DE,BUFFER   ; Start of input buffer
  915 05E9 7E           CRNCLP:    LD       A,(HL)      ; Get byte
  916 05EA FE20                    CP       ' '         ; Is it a space?
  917 05EC CA6806                  JP       Z,MOVDIR    ; Yes - Copy direct
  918 05EF 47                      LD       B,A         ; Save character
  919 05F0 FE22                    CP       '"'         ; Is it a quote?
  920 05F2 CA8806                  JP       Z,CPYLIT    ; Yes - Copy literal st
  921 05F5 B7                      OR       A           ; Is it end of buffer?
  922 05F6 CA8F06                  JP       Z,ENDBUF    ; Yes - End buffer
  923 05F9 3AF380                  LD       A,(DATFLG)  ; Get data type
  924 05FC B7                      OR       A           ; Literal?
  925 05FD 7E                      LD       A,(HL)      ; Get byte to copy
  926 05FE C26806                  JP       NZ,MOVDIR   ; Literal - Copy direct
  927 0601 FE3F                    CP       '?'         ; Is it '?' short for P
  928 0603 3E9E                    LD       A,ZPRINT    ; "PRINT" token
  929 0605 CA6806                  JP       Z,MOVDIR    ; Yes - replace it
  930 0608 7E                      LD       A,(HL)      ; Get byte again
  931 0609 FE30                    CP       '0'         ; Is it less than '0'
  932 060B DA1306                  JP       C,FNDWRD    ; Yes - Look for reserv
  933 060E FE3C                    CP       60          ; ";"+1; Is it "0123456
  934 0610 DA6806                  JP       C,MOVDIR    ; Yes - copy it direct
  935 0613 D5           FNDWRD:    PUSH     DE          ; Look for reserved wor
  936 0614 110C02                  LD       DE,WORDS-1  ; Point to table
  937 0617 C5                      PUSH     BC          ; Save count
  938 0618 016406                  LD       BC,RETNAD   ; Where to return to
  939 061B C5                      PUSH     BC          ; Save return address
  940 061C 067F                    LD       B,ZEND-1    ; First token value -1
  941 061E 7E                      LD       A,(HL)      ; Get byte
  942 061F FE61                    CP       'a'         ; Less than 'a' ?
  943 0621 DA2C06                  JP       C,SEARCH    ; Yes - search for word
  944 0624 FE7B                    CP       'z'+1       ; Greater than 'z' ?
  945 0626 D22C06                  JP       NC,SEARCH   ; Yes - search for word
  946 0629 E65F                    AND      01011111B   ; Force upper case
  947 062B 77                      LD       (HL),A      ; Replace byte
  948 062C 4E           SEARCH:    LD       C,(HL)      ; Search for a word
  949 062D EB                      EX       DE,HL
  950 062E 23           GETNXT:    INC      HL          ; Get next reserved wor
  951 062F B6                      OR       (HL)        ; Start of word?
  952 0630 F22E06                  JP       P,GETNXT    ; No - move on
  953 0633 04                      INC      B           ; Increment token value
  954 0634 7E                      LD       A, (HL)     ; Get byte from table
  955 0635 E67F                    AND      01111111B   ; Strip bit 7
  956 0637 C8                      RET      Z           ; Return if end of list
  957 0638 B9                      CP       C           ; Same character as in 
  958 0639 C22E06                  JP       NZ,GETNXT   ; No - get next word
  959 063C EB                      EX       DE,HL
  960 063D E5                      PUSH     HL          ; Save start of word
  961                   ;
  962 063E 13           NXTBYT:    INC      DE          ; Look through rest of 
  963 063F 1A                      LD       A,(DE)      ; Get byte from table
  964 0640 B7                      OR       A           ; End of word ?
  965 0641 FA6006                  JP       M,MATCH     ; Yes - Match found
  966 0644 4F                      LD       C,A         ; Save it
  967 0645 78                      LD       A,B         ; Get token value
  968 0646 FE88                    CP       ZGOTO       ; Is it "GOTO" token ?
  969 0648 C24F06                  JP       NZ,NOSPC    ; No - Don't allow spac
  970 064B CDDC08                  CALL     GETCHR      ; Get next character
  971 064E 2B                      DEC      HL          ; Cancel increment from
  972 064F 23           NOSPC:     INC      HL          ; Next byte
  973 0650 7E                      LD       A,(HL)      ; Get byte
  974 0651 FE61                    CP       'a'         ; Less than 'a' ?
  975 0653 DA5806                  JP       C,NOCHNG    ; Yes - don't change
  976 0656 E65F                    AND      01011111B   ; Make upper case
  977 0658 B9           NOCHNG:    CP       C           ; Same as in buffer ?
  978 0659 CA3E06                  JP       Z,NXTBYT    ; Yes - keep testing
  979 065C E1                      POP      HL          ; Get back start of wor
  980 065D C32C06                  JP       SEARCH      ; Look at next word
  981                   ;
  982 0660 48           MATCH:     LD       C,B         ; Word found - Save tok
  983 0661 F1                      POP      AF          ; Throw away return
  984 0662 EB                      EX       DE,HL
  985 0663 C9                      RET                  ; Return to "RETNAD"
  986 0664 EB           RETNAD:    EX       DE,HL       ; Get address in string
  987 0665 79                      LD       A,C         ; Get token value
  988 0666 C1                      POP      BC          ; Restore buffer length
  989 0667 D1                      POP      DE          ; Get destination addre
  990 0668 23           MOVDIR:    INC      HL          ; Next source in buffer
  991 0669 12                      LD       (DE),A      ; Put byte in buffer
  992 066A 13                      INC      DE          ; Move up buffer
  993 066B 0C                      INC      C           ; Increment length of b
  994 066C D63A                    SUB      ':'         ; End of statement?
  995 066E CA7606                  JP       Z,SETLIT    ; Jump if multi-stateme
  996 0671 FE49                    CP       ZDATA-3AH   ; Is it DATA statement 
  997 0673 C27906                  JP       NZ,TSTREM   ; No - see if REM
  998 0676 32F380       SETLIT:    LD       (DATFLG),A  ; Set literal flag
  999 0679 D654         TSTREM:    SUB      ZREM-3AH    ; Is it REM?
 1000 067B C2E905                  JP       NZ,CRNCLP   ; No - Leave flag
 1001 067E 47                      LD       B,A         ; Copy rest of buffer
 1002 067F 7E           NXTCHR:    LD       A,(HL)      ; Get byte
 1003 0680 B7                      OR       A           ; End of line ?
 1004 0681 CA8F06                  JP       Z,ENDBUF    ; Yes - Terminate buffe
 1005 0684 B8                      CP       B           ; End of statement ?
 1006 0685 CA6806                  JP       Z,MOVDIR    ; Yes - Get next one
 1007 0688 23           CPYLIT:    INC      HL          ; Move up source string
 1008 0689 12                      LD       (DE),A      ; Save in destination
 1009 068A 0C                      INC      C           ; Increment length
 1010 068B 13                      INC      DE          ; Move up destination
 1011 068C C37F06                  JP       NXTCHR      ; Repeat
 1012                   ;
 1013 068F 21A580       ENDBUF:    LD       HL,BUFFER-1 ; Point to start of buf
 1014 0692 12                      LD       (DE),A      ; Mark end of buffer (A
 1015 0693 13                      INC      DE
 1016 0694 12                      LD       (DE),A      ; A = 00
 1017 0695 13                      INC      DE
 1018 0696 12                      LD       (DE),A      ; A = 00
 1019 0697 C9                      RET
 1020                   ;
 1021 0698 3A8980       DODEL:     LD       A,(NULFLG)  ; Get null flag status
 1022 069B B7                      OR       A           ; Is it zero?
 1023 069C 3E00                    LD       A,0         ; Zero A - Leave flags
 1024 069E 328980                  LD       (NULFLG),A  ; Zero null flag
 1025 06A1 C2AC06                  JP       NZ,ECHDEL   ; Set - Echo it
 1026 06A4 05                      DEC      B           ; Decrement length
 1027 06A5 CAC906                  JP       Z,GETLIN    ; Get line again if emp
 1028 06A8 CD5D07                  CALL     OUTC        ; Output null character
 1029 06AB 3E                      DB       3EH         ; Skip "DEC B"
 1030 06AC 05           ECHDEL:    DEC      B           ; Count bytes in buffer
 1031 06AD 2B                      DEC      HL          ; Back space buffer
 1032 06AE CAC006                  JP       Z,OTKLN     ; No buffer - Try again
 1033 06B1 7E                      LD       A,(HL)      ; Get deleted byte
 1034 06B2 CD5D07                  CALL     OUTC        ; Echo it
 1035 06B5 C3D206                  JP       MORINP      ; Get more input
 1036                   ;
 1037 06B8 05           DELCHR:    DEC      B           ; Count bytes in buffer
 1038 06B9 2B                      DEC      HL          ; Back space buffer
 1039 06BA CD5D07                  CALL     OUTC        ; Output character in A
 1040 06BD C2D206                  JP       NZ,MORINP   ; Not end - Get more
 1041 06C0 CD5D07       OTKLN:     CALL     OUTC        ; Output character in A
 1042 06C3 CD840B       KILIN:     CALL     PRCRLF      ; Output CRLF
 1043 06C6 C3C906                  JP       TTYLIN      ; Get line again
 1044                   ;
 1045 06C9              GETLIN:
 1046 06C9 21A680       TTYLIN:    LD       HL,BUFFER   ; Get a line by charact
 1047 06CC 0601                    LD       B,1         ; Set buffer as empty
 1048 06CE AF                      XOR      A
 1049 06CF 328980                  LD       (NULFLG),A  ; Clear null flag
 1050 06D2 CD8707       MORINP:    CALL     CLOTST      ; Get character and tes
 1051 06D5 4F                      LD       C,A         ; Save character in C
 1052 06D6 FE7F                    CP       DEL         ; Delete character?
 1053 06D8 CA9806                  JP       Z,DODEL     ; Yes - Process it
 1054 06DB 3A8980                  LD       A,(NULFLG)  ; Get null flag
 1055 06DE B7                      OR       A           ; Test null flag status
 1056 06DF CAEB06                  JP       Z,PROCES    ; Reset - Process chara
 1057 06E2 3E00                    LD       A,0         ; Set a null
 1058 06E4 CD5D07                  CALL     OUTC        ; Output null
 1059 06E7 AF                      XOR      A           ; Clear A
 1060 06E8 328980                  LD       (NULFLG),A  ; Reset null flag
 1061 06EB 79           PROCES:    LD       A,C         ; Get character
 1062 06EC FE07                    CP       CTRLG       ; Bell?
 1063 06EE CA2F07                  JP       Z,PUTCTL    ; Yes - Save it
 1064 06F1 FE03                    CP       CTRLC       ; Is it control "C"?
 1065 06F3 CC840B                  CALL     Z,PRCRLF    ; Yes - Output CRLF
 1066 06F6 37                      SCF                  ; Flag break
 1067 06F7 C8                      RET      Z           ; Return if control "C"
 1068 06F8 FE0D                    CP       CR          ; Is it enter?
 1069 06FA CA7F0B                  JP       Z,ENDINP    ; Yes - Terminate input
 1070 06FD FE15                    CP       CTRLU       ; Is it control "U"?
 1071 06FF CAC306                  JP       Z,KILIN     ; Yes - Get another lin
 1072 0702 FE40                    CP       '@'         ; Is it "kill line"?
 1073 0704 CAC006                  JP       Z,OTKLN     ; Yes - Kill line
 1074 0707 FE5F                    CP       '_'         ; Is it delete?
 1075 0709 CAB806                  JP       Z,DELCHR    ; Yes - Delete characte
 1076 070C FE08                    CP       BKSP        ; Is it backspace?
 1077 070E CAB806                  JP       Z,DELCHR    ; Yes - Delete characte
 1078 0711 FE12                    CP       CTRLR       ; Is it control "R"?
 1079 0713 C22A07                  JP       NZ,PUTBUF   ; No - Put in buffer
 1080 0716 C5                      PUSH     BC          ; Save buffer length
 1081 0717 D5                      PUSH     DE          ; Save DE
 1082 0718 E5                      PUSH     HL          ; Save buffer address
 1083 0719 3600                    LD       (HL),0      ; Mark end of buffer
 1084 071B CD2E1D                  CALL     OUTNCR      ; Output and do CRLF
 1085 071E 21A680                  LD       HL,BUFFER   ; Point to buffer start
 1086 0721 CD2212                  CALL     PRS         ; Output buffer
 1087 0724 E1                      POP      HL          ; Restore buffer addres
 1088 0725 D1                      POP      DE          ; Restore DE
 1089 0726 C1                      POP      BC          ; Restore buffer length
 1090 0727 C3D206                  JP       MORINP      ; Get another character
 1091                   ;
 1092 072A FE20         PUTBUF:    CP       ' '         ; Is it a control code?
 1093 072C DAD206                  JP       C,MORINP    ; Yes - Ignore
 1094 072F 78           PUTCTL:    LD       A,B         ; Get number of bytes i
 1095 0730 FE49                    CP       72+1        ; Test for line overflo
 1096 0732 3E07                    LD       A,CTRLG     ; Set a bell
 1097 0734 D24407                  JP       NC,OUTNBS   ; Ring bell if buffer f
 1098 0737 79                      LD       A,C         ; Get character
 1099 0738 71                      LD       (HL),C      ; Save in buffer
 1100 0739 321181                  LD       (LSTBIN),A  ; Save last input byte
 1101 073C 23                      INC      HL          ; Move up buffer
 1102 073D 04                      INC      B           ; Increment length
 1103 073E CD5D07       OUTIT:     CALL     OUTC        ; Output the character 
 1104 0741 C3D206                  JP       MORINP      ; Get another character
 1105                   ;
 1106 0744 CD5D07       OUTNBS:    CALL     OUTC        ; Output bell and back 
 1107 0747 3E08                    LD       A,BKSP      ; Set back space
 1108 0749 C33E07                  JP       OUTIT       ; Output it and get mor
 1109                   ;
 1110 074C 7C           CPDEHL:    LD       A,H         ; Get H
 1111 074D 92                      SUB      D           ; Compare with D
 1112 074E C0                      RET      NZ          ; Different - Exit
 1113 074F 7D                      LD       A,L         ; Get L
 1114 0750 93                      SUB      E           ; Compare with E
 1115 0751 C9                      RET                  ; Return status
 1116                   ;
 1117 0752 7E           CHKSYN:    LD       A,(HL)      ; Check syntax of chara
 1118 0753 E3                      EX       (SP),HL     ; Address of test byte
 1119 0754 BE                      CP       (HL)        ; Same as in code strin
 1120 0755 23                      INC      HL          ; Return address
 1121 0756 E3                      EX       (SP),HL     ; Put it back
 1122 0757 CADC08                  JP       Z,GETCHR    ; Yes - Get next charac
 1123 075A C38404                  JP       SNERR       ; Different - ?SN Error
 1124                   ;
 1125 075D F5           OUTC:      PUSH     AF          ; Save character
 1126 075E 3A8A80                  LD       A,(CTLOFG)  ; Get control "O" flag
 1127 0761 B7                      OR       A           ; Is it set?
 1128 0762 C25712                  JP       NZ,POPAF    ; Yes - don't output
 1129 0765 F1                      POP      AF          ; Restore character
 1130 0766 C5                      PUSH     BC          ; Save buffer length
 1131 0767 F5                      PUSH     AF          ; Save character
 1132 0768 FE20                    CP       ' '         ; Is it a control code?
 1133 076A DA8107                  JP       C,DINPOS    ; Yes - Don't INC POS(X
 1134 076D 3A8780                  LD       A,(LWIDTH)  ; Get line width
 1135 0770 47                      LD       B,A         ; To B
 1136 0771 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1137 0774 04                      INC      B           ; Width 255?
 1138 0775 CA7D07                  JP       Z,INCLEN    ; Yes - No width limit
 1139 0778 05                      DEC      B           ; Restore width
 1140 0779 B8                      CP       B           ; At end of line?
 1141 077A CC840B                  CALL     Z,PRCRLF    ; Yes - output CRLF
 1142 077D 3C           INCLEN:    INC      A           ; Move on one character
 1143 077E 32F080                  LD       (CURPOS),A  ; Save new position
 1144 0781 F1           DINPOS:    POP      AF          ; Restore character
 1145 0782 C1                      POP      BC          ; Restore buffer length
 1146 0783 CD191D                  CALL     MONOUT      ; Send it
 1147 0786 C9                      RET
 1148                   ;
 1149 0787 CDE11B       CLOTST:    CALL     GETINP      ; Get input character
 1150 078A E67F                    AND      01111111B   ; Strip bit 7
 1151 078C FE0F                    CP       CTRLO       ; Is it control "O"?
 1152 078E C0                      RET      NZ          ; No don't flip flag
 1153 078F 3A8A80                  LD       A,(CTLOFG)  ; Get flag
 1154 0792 2F                      CPL                  ; Flip it
 1155 0793 328A80                  LD       (CTLOFG),A  ; Put it back
 1156 0796 AF                      XOR      A           ; Null character
 1157 0797 C9                      RET
 1158                   ;
 1159 0798 CDA809       LIST:      CALL     ATOH        ; ASCII number to DE
 1160 079B C0                      RET      NZ          ; Return if anything ex
 1161 079C C1                      POP      BC          ; Rubbish - Not needed
 1162 079D CD7005                  CALL     SRCHLN      ; Search for line numbe
 1163 07A0 C5                      PUSH     BC          ; Save address of line
 1164 07A1 CDEE07                  CALL     SETLIN      ; Set up lines counter
 1165 07A4 E1           LISTLP:    POP      HL          ; Restore address of li
 1166 07A5 4E                      LD       C,(HL)      ; Get LSB of next line
 1167 07A6 23                      INC      HL
 1168 07A7 46                      LD       B,(HL)      ; Get MSB of next line
 1169 07A8 23                      INC      HL
 1170 07A9 78                      LD       A,B         ; BC = 0 (End of progra
 1171 07AA B1                      OR       C
 1172 07AB CACF04                  JP       Z,PRNTOK    ; Yes - Go to command m
 1173 07AE CDF707                  CALL     COUNT       ; Count lines
 1174 07B1 CD0709                  CALL     TSTBRK      ; Test for break key
 1175 07B4 C5                      PUSH     BC          ; Save address of next 
 1176 07B5 CD840B                  CALL     PRCRLF      ; Output CRLF
 1177 07B8 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1178 07B9 23                      INC      HL
 1179 07BA 56                      LD       D,(HL)      ; Get MSB of line numbe
 1180 07BB 23                      INC      HL
 1181 07BC E5                      PUSH     HL          ; Save address of line 
 1182 07BD EB                      EX       DE,HL       ; Line number to HL
 1183 07BE CDC518                  CALL     PRNTHL      ; Output line number in
 1184 07C1 3E20                    LD       A,' '       ; Space after line numb
 1185 07C3 E1                      POP      HL          ; Restore start of line
 1186 07C4 CD5D07       LSTLP2:    CALL     OUTC        ; Output character in A
 1187 07C7 7E           LSTLP3:    LD       A,(HL)      ; Get next byte in line
 1188 07C8 B7                      OR       A           ; End of line?
 1189 07C9 23                      INC      HL          ; To next byte in line
 1190 07CA CAA407                  JP       Z,LISTLP    ; Yes - get next line
 1191 07CD F2C407                  JP       P,LSTLP2    ; No token - output it
 1192 07D0 D67F                    SUB      ZEND-1      ; Find and output word
 1193 07D2 4F                      LD       C,A         ; Token offset+1 to C
 1194 07D3 110D02                  LD       DE,WORDS    ; Reserved word list
 1195 07D6 1A           FNDTOK:    LD       A,(DE)      ; Get character in list
 1196 07D7 13                      INC      DE          ; Move on to next
 1197 07D8 B7                      OR       A           ; Is it start of word?
 1198 07D9 F2D607                  JP       P,FNDTOK    ; No - Keep looking for
 1199 07DC 0D                      DEC      C           ; Count words
 1200 07DD C2D607                  JP       NZ,FNDTOK   ; Not there - keep look
 1201 07E0 E67F         OUTWRD:    AND      01111111B   ; Strip bit 7
 1202 07E2 CD5D07                  CALL     OUTC        ; Output first characte
 1203 07E5 1A                      LD       A,(DE)      ; Get next character
 1204 07E6 13                      INC      DE          ; Move on to next
 1205 07E7 B7                      OR       A           ; Is it end of word?
 1206 07E8 F2E007                  JP       P,OUTWRD    ; No - output the rest
 1207 07EB C3C707                  JP       LSTLP3      ; Next byte in line
 1208                   ;
 1209 07EE E5           SETLIN:    PUSH     HL          ; Set up LINES counter
 1210 07EF 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1211 07F2 228B80                  LD       (LINESC),HL ; Save in LINES counter
 1212 07F5 E1                      POP      HL
 1213 07F6 C9                      RET
 1214                   ;
 1215 07F7 E5           COUNT:     PUSH     HL          ; Save code string addr
 1216 07F8 D5                      PUSH     DE
 1217 07F9 2A8B80                  LD       HL,(LINESC) ; Get LINES counter
 1218 07FC 11FFFF                  LD       DE,-1
 1219 07FF ED5A                    ADC      HL,DE       ; Decrement
 1220 0801 228B80                  LD       (LINESC),HL ; Put it back
 1221 0804 D1                      POP      DE
 1222 0805 E1                      POP      HL          ; Restore code string a
 1223 0806 F0                      RET      P           ; Return if more lines 
 1224 0807 E5                      PUSH     HL          ; Save code string addr
 1225 0808 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1226 080B 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1227 080E CDE11B                  CALL     GETINP      ; Get input character
 1228 0811 FE03                    CP       CTRLC       ; Is it control "C"?
 1229 0813 CA1A08                  JP       Z,RSLNBK    ; Yes - Reset LINES and
 1230 0816 E1                      POP      HL          ; Restore code string a
 1231 0817 C3F707                  JP       COUNT       ; Keep on counting
 1232                   ;
 1233 081A 2A8D80       RSLNBK:    LD       HL,(LINESN) ; Get LINES number
 1234 081D 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1235 0820 C34E01                  JP       BRKRET      ; Go and output "Break"
 1236                   ;
 1237 0823 3E64         FOR:       LD       A,64H       ; Flag "FOR" assignment
 1238 0825 321081                  LD       (FORFLG),A  ; Save "FOR" flag
 1239 0828 CD8A0A                  CALL     LET         ; Set up initial index
 1240 082B C1                      POP      BC          ; Drop RETurn address
 1241 082C E5                      PUSH     HL          ; Save code string addr
 1242 082D CD730A                  CALL     DATA        ; Get next statement ad
 1243 0830 220C81                  LD       (LOOPST),HL ; Save it for start of 
 1244 0833 210200                  LD       HL,2        ; Offset for "FOR" bloc
 1245 0836 39                      ADD      HL,SP       ; Point to it
 1246 0837 CD3104       FORSLP:    CALL     LOKFOR      ; Look for existing "FO
 1247 083A D1                      POP      DE          ; Get code string addre
 1248 083B C25308                  JP       NZ,FORFND   ; No nesting found
 1249 083E 09                      ADD      HL,BC       ; Move into "FOR" block
 1250 083F D5                      PUSH     DE          ; Save code string addr
 1251 0840 2B                      DEC      HL
 1252 0841 56                      LD       D,(HL)      ; Get MSB of loop state
 1253 0842 2B                      DEC      HL
 1254 0843 5E                      LD       E,(HL)      ; Get LSB of loop state
 1255 0844 23                      INC      HL
 1256 0845 23                      INC      HL
 1257 0846 E5                      PUSH     HL          ; Save block address
 1258 0847 2A0C81                  LD       HL,(LOOPST) ; Get address of loop s
 1259 084A CD4C07                  CALL     CPDEHL      ; Compare the FOR loops
 1260 084D E1                      POP      HL          ; Restore block address
 1261 084E C23708                  JP       NZ,FORSLP   ; Different FORs - Find
 1262 0851 D1                      POP      DE          ; Restore code string a
 1263 0852 F9                      LD       SP,HL       ; Remove all nested loo
 1264                   ;
 1265 0853 EB           FORFND:    EX       DE,HL       ; Code string address t
 1266 0854 0E08                    LD       C,8
 1267 0856 CD6104                  CALL     CHKSTK      ; Check for 8 levels of
 1268 0859 E5                      PUSH     HL          ; Save code string addr
 1269 085A 2A0C81                  LD       HL,(LOOPST) ; Get first statement o
 1270 085D E3                      EX       (SP),HL     ; Save and restore code
 1271 085E E5                      PUSH     HL          ; Re-save code string a
 1272 085F 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 1273 0862 E3                      EX       (SP),HL     ; Save and restore code
 1274 0863 CD4C0D                  CALL     TSTNUM      ; Make sure it's a numb
 1275 0866 CD5207                  CALL     CHKSYN      ; Make sure "TO" is nex
 1276 0869 A6                      DB       ZTO         ; "TO" token
 1277 086A CD490D                  CALL     GETNUM      ; Get "TO" expression v
 1278 086D E5                      PUSH     HL          ; Save code string addr
 1279 086E CD7717                  CALL     BCDEFP      ; Move "TO" value to BC
 1280 0871 E1                      POP      HL          ; Restore code string a
 1281 0872 C5                      PUSH     BC          ; Save "TO" value in bl
 1282 0873 D5                      PUSH     DE
 1283 0874 010081                  LD       BC,8100H    ; BCDE - 1 (default STE
 1284 0877 51                      LD       D,C         ; C=0
 1285 0878 5A                      LD       E,D         ; D=0
 1286 0879 7E                      LD       A,(HL)      ; Get next byte in code
 1287 087A FEAB                    CP       ZSTEP       ; See if "STEP" is stat
 1288 087C 3E01                    LD       A,1         ; Sign of step = 1
 1289 087E C28F08                  JP       NZ,SAVSTP   ; No STEP given - Defau
 1290 0881 CDDC08                  CALL     GETCHR      ; Jump over "STEP" toke
 1291 0884 CD490D                  CALL     GETNUM      ; Get step value
 1292 0887 E5                      PUSH     HL          ; Save code string addr
 1293 0888 CD7717                  CALL     BCDEFP      ; Move STEP to BCDE
 1294 088B CD2B17                  CALL     TSTSGN      ; Test sign of FPREG
 1295 088E E1                      POP      HL          ; Restore code string a
 1296 088F C5           SAVSTP:    PUSH     BC          ; Save the STEP value i
 1297 0890 D5                      PUSH     DE
 1298 0891 F5                      PUSH     AF          ; Save sign of STEP
 1299 0892 33                      INC      SP          ; Don't save flags
 1300 0893 E5                      PUSH     HL          ; Save code string addr
 1301 0894 2A1381                  LD       HL,(BRKLIN) ; Get address of index 
 1302 0897 E3                      EX       (SP),HL     ; Save and restore code
 1303 0898 0681         PUTFID:    LD       B,ZFOR      ; "FOR" block marker
 1304 089A C5                      PUSH     BC          ; Save it
 1305 089B 33                      INC      SP          ; Don't save C
 1306                   ;
 1307 089C CD0709       RUNCNT:    CALL     TSTBRK      ; Execution driver - Te
 1308 089F 221381                  LD       (BRKLIN),HL ; Save code address for
 1309 08A2 7E                      LD       A,(HL)      ; Get next byte in code
 1310 08A3 FE3A                    CP       ':'         ; Multi statement line?
 1311 08A5 CABC08                  JP       Z,EXCUTE    ; Yes - Execute it
 1312 08A8 B7                      OR       A           ; End of line?
 1313 08A9 C28404                  JP       NZ,SNERR    ; No - Syntax error
 1314 08AC 23                      INC      HL          ; Point to address of n
 1315 08AD 7E                      LD       A,(HL)      ; Get LSB of line point
 1316 08AE 23                      INC      HL
 1317 08AF B6                      OR       (HL)        ; Is it zero (End of pr
 1318 08B0 CA2E09                  JP       Z,ENDPRG    ; Yes - Terminate execu
 1319 08B3 23                      INC      HL          ; Point to line number
 1320 08B4 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1321 08B5 23                      INC      HL
 1322 08B6 56                      LD       D,(HL)      ; Get MSB of line numbe
 1323 08B7 EB                      EX       DE,HL       ; Line number to HL
 1324 08B8 22A180                  LD       (LINEAT),HL ; Save as current line 
 1325 08BB EB                      EX       DE,HL       ; Line number back to D
 1326 08BC CDDC08       EXCUTE:    CALL     GETCHR      ; Get key word
 1327 08BF 119C08                  LD       DE,RUNCNT   ; Where to RETurn to
 1328 08C2 D5                      PUSH     DE          ; Save for RETurn
 1329 08C3 C8           IFJMP:     RET      Z           ; Go to RUNCNT if end o
 1330 08C4 D680         ONJMP:     SUB      ZEND        ; Is it a token?
 1331 08C6 DA8A0A                  JP       C,LET       ; No - try to assign it
 1332 08C9 FE25                    CP       ZNEW+1-ZEND ; END to NEW ?
 1333 08CB D28404                  JP       NC,SNERR    ; Not a key word - ?SN 
 1334 08CE 07                      RLCA                 ; Double it
 1335 08CF 4F                      LD       C,A         ; BC = Offset into tabl
 1336 08D0 0600                    LD       B,0
 1337 08D2 EB                      EX       DE,HL       ; Save code string addr
 1338 08D3 212C03                  LD       HL,WORDTB   ; Keyword address table
 1339 08D6 09                      ADD      HL,BC       ; Point to routine addr
 1340 08D7 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1341 08D8 23                      INC      HL
 1342 08D9 46                      LD       B,(HL)      ; Get MSB of routine ad
 1343 08DA C5                      PUSH     BC          ; Save routine address
 1344 08DB EB                      EX       DE,HL       ; Restore code string a
 1345                   ;
 1346 08DC 23           GETCHR:    INC      HL          ; Point to next charact
 1347 08DD 7E                      LD       A,(HL)      ; Get next code string 
 1348 08DE FE3A                    CP       ':'         ; Z if ':'
 1349 08E0 D0                      RET      NC          ; NC if > "9"
 1350 08E1 FE20                    CP       ' '
 1351 08E3 CADC08                  JP       Z,GETCHR    ; Skip over spaces
 1352 08E6 FE30                    CP       '0'
 1353 08E8 3F                      CCF                  ; NC if < '0'
 1354 08E9 3C                      INC      A           ; Test for zero - Leave
 1355 08EA 3D                      DEC      A           ; Z if Null
 1356 08EB C9                      RET
 1357                   ;
 1358 08EC EB           RESTOR:    EX       DE,HL       ; Save code string addr
 1359 08ED 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1360 08F0 CA0109                  JP       Z,RESTNL    ; Just RESTORE - reset 
 1361 08F3 EB                      EX       DE,HL       ; Restore code string a
 1362 08F4 CDA809                  CALL     ATOH        ; Get line number to DE
 1363 08F7 E5                      PUSH     HL          ; Save code string addr
 1364 08F8 CD7005                  CALL     SRCHLN      ; Search for line numbe
 1365 08FB 60                      LD       H,B         ; HL = Address of line
 1366 08FC 69                      LD       L,C
 1367 08FD D1                      POP      DE          ; Restore code string a
 1368 08FE D2490A                  JP       NC,ULERR    ; ?UL Error if not foun
 1369 0901 2B           RESTNL:    DEC      HL          ; Byte before DATA stat
 1370 0902 222181       UPDATA:    LD       (NXTDAT),HL ; Update DATA pointer
 1371 0905 EB                      EX       DE,HL       ; Restore code string a
 1372 0906 C9                      RET
 1373                   ;
 1374                   
 1375 0907 DF           TSTBRK:    RST      18H         ; Check input status
 1376 0908 C8                      RET      Z           ; No key, go back
 1377 0909 D7                      RST      10H         ; Get the key into A
 1378 090A FE1B                    CP       ESC         ; Escape key?
 1379 090C 2811                    JR       Z,BRK       ; Yes, break
 1380 090E FE03                    CP       CTRLC       ; <Ctrl-C>
 1381 0910 280D                    JR       Z,BRK       ; Yes, break
 1382 0912 FE13                    CP       CTRLS       ; Stop scrolling?
 1383 0914 C0                      RET      NZ          ; Other key, ignore
 1384                   ;
 1385                   
 1386 0915 D7           STALL:     RST      10H         ; Wait for key
 1387 0916 FE11                    CP       CTRLQ       ; Resume scrolling?
 1388 0918 C8                      RET      Z           ; Release the chokehold
 1389 0919 FE03                    CP       CTRLC       ; Second break?
 1390 091B 2807                    JR       Z,STOP      ; Break during hold exi
 1391 091D 18F6                    JR       STALL       ; Loop until <Ctrl-Q> o
 1392                   ;
 1393 091F 3EFF         BRK        LD       A,0FFH      ; Set BRKFLG
 1394 0921 329280                  LD       (BRKFLG),A  ; Store it
 1395                   ;
 1396                   
 1397 0924 C0           STOP:      RET      NZ          ; Exit if anything else
 1398 0925 F6                      DB       0F6H        ; Flag "STOP"
 1399 0926 C0           PEND:      RET      NZ          ; Exit if anything else
 1400 0927 221381                  LD       (BRKLIN),HL ; Save point of break
 1401 092A 21                      DB       21H         ; Skip "OR 11111111B"
 1402 092B F6FF         INPBRK:    OR       11111111B   ; Flag "Break" wanted
 1403 092D C1                      POP      BC          ; Return not needed and
 1404 092E 2AA180       ENDPRG:    LD       HL,(LINEAT) ; Get current line numb
 1405 0931 F5                      PUSH     AF          ; Save STOP / END statu
 1406 0932 7D                      LD       A,L         ; Is it direct break?
 1407 0933 A4                      AND      H
 1408 0934 3C                      INC      A           ; Line is -1 if direct 
 1409 0935 CA4109                  JP       Z,NOLIN     ; Yes - No line number
 1410 0938 221781                  LD       (ERRLIN),HL ; Save line of break
 1411 093B 2A1381                  LD       HL,(BRKLIN) ; Get point of break
 1412 093E 221981                  LD       (CONTAD),HL ; Save point to CONTinu
 1413 0941 AF           NOLIN:     XOR      A
 1414 0942 328A80                  LD       (CTLOFG),A  ; Enable output
 1415 0945 CD770B                  CALL     STTLIN      ; Start a new line
 1416 0948 F1                      POP      AF          ; Restore STOP / END st
 1417 0949 212704                  LD       HL,BRKMSG   ; "Break" message
 1418 094C C2B804                  JP       NZ,ERRIN    ; "in line" wanted?
 1419 094F C3CF04                  JP       PRNTOK      ; Go to command mode
 1420                   ;
 1421 0952 2A1981       CONT:      LD       HL,(CONTAD) ; Get CONTinue address
 1422 0955 7C                      LD       A,H         ; Is it zero?
 1423 0956 B5                      OR       L
 1424 0957 1E20                    LD       E,CN        ; ?CN Error
 1425 0959 CA9804                  JP       Z,ERROR     ; Yes - output "?CN Err
 1426 095C EB                      EX       DE,HL       ; Save code string addr
 1427 095D 2A1781                  LD       HL,(ERRLIN) ; Get line of last brea
 1428 0960 22A180                  LD       (LINEAT),HL ; Set up current line n
 1429 0963 EB                      EX       DE,HL       ; Restore code string a
 1430 0964 C9                      RET                  ; CONTinue where left o
 1431                   ;
 1432 0965 CDAA14       NULL:      CALL     GETINT      ; Get integer 0-255
 1433 0968 C0                      RET      NZ          ; Return if bad value
 1434 0969 328680                  LD       (NULLS),A   ; Set nulls number
 1435 096C C9                      RET
 1436                   ;
 1437                   
 1438 096D E5           ACCSUM:    PUSH     HL          ; Save address in array
 1439 096E 2A8F80                  LD       HL,(CHKSUM) ; Get check sum
 1440 0971 0600                    LD       B,0         ; BC - Value of byte
 1441 0973 4F                      LD       C,A
 1442 0974 09                      ADD      HL,BC       ; Add byte to check sum
 1443 0975 228F80                  LD       (CHKSUM),HL ; Re-save check sum
 1444 0978 E1                      POP      HL          ; Restore address in ar
 1445 0979 C9                      RET
 1446                   ;
 1447 097A 7E           CHKLTR:    LD       A,(HL)      ; Get byte
 1448 097B FE41                    CP       'A'         ; < 'a' ?
 1449 097D D8                      RET      C           ; Carry set if not lett
 1450 097E FE5B                    CP       'Z'+1       ; > 'z' ?
 1451 0980 3F                      CCF
 1452 0981 C9                      RET                  ; Carry set if not lett
 1453                   ;
 1454 0982 CDDC08       FPSINT:    CALL     GETCHR      ; Get next character
 1455 0985 CD490D       POSINT:    CALL     GETNUM      ; Get integer 0 to 3276
 1456 0988 CD2B17       DEPINT:    CALL     TSTSGN      ; Test sign of FPREG
 1457 098B FAA309                  JP       M,FCERR     ; Negative - ?FC Error
 1458 098E 3A2C81       DEINT:     LD       A,(FPEXP)   ; Get integer value to 
 1459 0991 FE90                    CP       80H+16      ; Exponent in range (16
 1460 0993 DAD317                  JP       C,FPINT     ; Yes - convert it
 1461 0996 018090                  LD       BC,9080H    ; BCDE = -32768
 1462 0999 110000                  LD       DE,0000
 1463 099C E5                      PUSH     HL          ; Save code string addr
 1464 099D CDA617                  CALL     CMPNUM      ; Compare FPREG with BC
 1465 09A0 E1                      POP      HL          ; Restore code string a
 1466 09A1 51                      LD       D,C         ; MSB to D
 1467 09A2 C8                      RET      Z           ; Return if in range
 1468 09A3 1E08         FCERR:     LD       E,FC        ; ?FC Error
 1469 09A5 C39804                  JP       ERROR       ; Output error-
 1470                   ;
 1471 09A8 2B           ATOH:      DEC      HL          ; ASCII number to DE bi
 1472 09A9 110000       GETLN:     LD       DE,0        ; Get number to DE
 1473 09AC CDDC08       GTLNLP:    CALL     GETCHR      ; Get next character
 1474 09AF D0                      RET      NC          ; Exit if not a digit
 1475 09B0 E5                      PUSH     HL          ; Save code string addr
 1476 09B1 F5                      PUSH     AF          ; Save digit
 1477 09B2 219819                  LD       HL,65529/10 ; Largest number 65529
 1478 09B5 CD4C07                  CALL     CPDEHL      ; Number in range?
 1479 09B8 DA8404                  JP       C,SNERR     ; No - ?SN Error
 1480 09BB 62                      LD       H,D         ; HL = Number
 1481 09BC 6B                      LD       L,E
 1482 09BD 19                      ADD      HL,DE       ; Times 2
 1483 09BE 29                      ADD      HL,HL       ; Times 4
 1484 09BF 19                      ADD      HL,DE       ; Times 5
 1485 09C0 29                      ADD      HL,HL       ; Times 10
 1486 09C1 F1                      POP      AF          ; Restore digit
 1487 09C2 D630                    SUB      '0'         ; Make it 0 to 9
 1488 09C4 5F                      LD       E,A         ; DE = Value of digit
 1489 09C5 1600                    LD       D,0
 1490 09C7 19                      ADD      HL,DE       ; Add to number
 1491 09C8 EB                      EX       DE,HL       ; Number to DE
 1492 09C9 E1                      POP      HL          ; Restore code string a
 1493 09CA C3AC09                  JP       GTLNLP      ; Go to next character
 1494                   ;
 1495 09CD CAA005       CLEAR:     JP       Z,INTVAR    ; Just "CLEAR" Keep par
 1496 09D0 CD8509                  CALL     POSINT      ; Get integer 0 to 3276
 1497 09D3 2B                      DEC      HL          ; Cancel increment
 1498 09D4 CDDC08                  CALL     GETCHR      ; Get next character
 1499 09D7 E5                      PUSH     HL          ; Save code string addr
 1500 09D8 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
 1501 09DB CAF009                  JP       Z,STORED    ; No value given - Use 
 1502 09DE E1                      POP      HL          ; Restore code string a
 1503 09DF CD5207                  CALL     CHKSYN      ; Check for comma
 1504 09E2 2C                      DB       ','
 1505 09E3 D5                      PUSH     DE          ; Save number
 1506 09E4 CD8509                  CALL     POSINT      ; Get integer 0 to 3276
 1507 09E7 2B                      DEC      HL          ; Cancel increment
 1508 09E8 CDDC08                  CALL     GETCHR      ; Get next character
 1509 09EB C28404                  JP       NZ,SNERR    ; ?SN Error if more on 
 1510 09EE E3                      EX       (SP),HL     ; Save code string addr
 1511 09EF EB                      EX       DE,HL       ; Number to DE
 1512 09F0 7D           STORED:    LD       A,L         ; Get LSB of new RAM to
 1513 09F1 93                      SUB      E           ; Subtract LSB of strin
 1514 09F2 5F                      LD       E,A         ; Save LSB
 1515 09F3 7C                      LD       A,H         ; Get MSB of new RAM to
 1516 09F4 9A                      SBC      A,D         ; Subtract MSB of strin
 1517 09F5 57                      LD       D,A         ; Save MSB
 1518 09F6 DA7904                  JP       C,OMERR     ; ?OM Error if not enou
 1519 09F9 E5                      PUSH     HL          ; Save RAM top
 1520 09FA 2A1B81                  LD       HL,(PROGND) ; Get program end
 1521 09FD 012800                  LD       BC,40       ; 40 Bytes minimum work
 1522 0A00 09                      ADD      HL,BC       ; Get lowest address
 1523 0A01 CD4C07                  CALL     CPDEHL      ; Enough memory?
 1524 0A04 D27904                  JP       NC,OMERR    ; No - ?OM Error
 1525 0A07 EB                      EX       DE,HL       ; RAM top to HL
 1526 0A08 229F80                  LD       (STRSPC),HL ; Set new string space
 1527 0A0B E1                      POP      HL          ; End of memory to use
 1528 0A0C 22F480                  LD       (LSTRAM),HL ; Set new top of RAM
 1529 0A0F E1                      POP      HL          ; Restore code string a
 1530 0A10 C3A005                  JP       INTVAR      ; Initialise variables
 1531                   ;
 1532 0A13 CA9C05       RUN:       JP       Z,RUNFST    ; RUN from start if jus
 1533 0A16 CDA005                  CALL     INTVAR      ; Initialise variables
 1534 0A19 019C08                  LD       BC,RUNCNT   ; Execution driver loop
 1535 0A1C C32F0A                  JP       RUNLIN      ; RUN from line number
 1536                   ;
 1537 0A1F 0E03         GOSUB:     LD       C,3         ; 3 Levels of stack nee
 1538 0A21 CD6104                  CALL     CHKSTK      ; Check for 3 levels of
 1539 0A24 C1                      POP      BC          ; Get return address
 1540 0A25 E5                      PUSH     HL          ; Save code string for 
 1541 0A26 E5                      PUSH     HL          ; And for GOSUB routine
 1542 0A27 2AA180                  LD       HL,(LINEAT) ; Get current line
 1543 0A2A E3                      EX       (SP),HL     ; Into stack - Code str
 1544 0A2B 3E8C                    LD       A,ZGOSUB    ; "GOSUB" token
 1545 0A2D F5                      PUSH     AF          ; Save token
 1546 0A2E 33                      INC      SP          ; Don't save flags
 1547                   ;
 1548 0A2F C5           RUNLIN:    PUSH     BC          ; Save return address
 1549 0A30 CDA809       GOTO:      CALL     ATOH        ; ASCII number to DE bi
 1550 0A33 CD750A                  CALL     REM         ; Get end of line
 1551 0A36 E5                      PUSH     HL          ; Save end of line
 1552 0A37 2AA180                  LD       HL,(LINEAT) ; Get current line
 1553 0A3A CD4C07                  CALL     CPDEHL      ; Line after current?
 1554 0A3D E1                      POP      HL          ; Restore end of line
 1555 0A3E 23                      INC      HL          ; Start of next line
 1556 0A3F DC7305                  CALL     C,SRCHLP    ; Line is after current
 1557 0A42 D47005                  CALL     NC,SRCHLN   ; Line is before curren
 1558 0A45 60                      LD       H,B         ; Set up code string ad
 1559 0A46 69                      LD       L,C
 1560 0A47 2B                      DEC      HL          ; Incremented after
 1561 0A48 D8                      RET      C           ; Line found
 1562 0A49 1E0E         ULERR:     LD       E,UL        ; ?UL Error
 1563 0A4B C39804                  JP       ERROR       ; Output error message
 1564                   ;
 1565 0A4E C0           RETURN:    RET      NZ          ; Return if not just RE
 1566 0A4F 16FF                    LD       D,-1        ; Flag "GOSUB" search
 1567 0A51 CD2D04                  CALL     BAKSTK      ; Look "GOSUB" block
 1568 0A54 F9                      LD       SP,HL       ; Kill all FORs in subr
 1569 0A55 FE8C                    CP       ZGOSUB      ; Test for "GOSUB" toke
 1570 0A57 1E04                    LD       E,RG        ; ?RG Error
 1571 0A59 C29804                  JP       NZ,ERROR    ; Error if no "GOSUB" f
 1572 0A5C E1                      POP      HL          ; Get RETURN line numbe
 1573 0A5D 22A180                  LD       (LINEAT),HL ; Save as current
 1574 0A60 23                      INC      HL          ; Was it from direct st
 1575 0A61 7C                      LD       A,H
 1576 0A62 B5                      OR       L           ; Return to line
 1577 0A63 C26D0A                  JP       NZ,RETLIN   ; No - Return to line
 1578 0A66 3A1181                  LD       A,(LSTBIN)  ; Any INPUT in subrouti
 1579 0A69 B7                      OR       A           ; If so buffer is corru
 1580 0A6A C2CE04                  JP       NZ,POPNOK   ; Yes - Go to command m
 1581 0A6D 219C08       RETLIN:    LD       HL,RUNCNT   ; Execution driver loop
 1582 0A70 E3                      EX       (SP),HL     ; Into stack - Code str
 1583 0A71 3E                      DB       3EH         ; Skip "POP HL"
 1584 0A72 E1           NXTDTA:    POP      HL          ; Restore code string a
 1585                   ;
 1586 0A73 013A         DATA:      DB       01H,3AH     ; ':' End of statement
 1587 0A75 0E00         REM:       LD       C,0         ; 00    End of statemen
 1588 0A77 0600                    LD       B,0
 1589 0A79 79           NXTSTL:    LD       A,C         ; Statement and byte
 1590 0A7A 48                      LD       C,B
 1591 0A7B 47                      LD       B,A         ; Statement end byte
 1592 0A7C 7E           NXTSTT:    LD       A,(HL)      ; Get byte
 1593 0A7D B7                      OR       A           ; End of line?
 1594 0A7E C8                      RET      Z           ; Yes - Exit
 1595 0A7F B8                      CP       B           ; End of statement?
 1596 0A80 C8                      RET      Z           ; Yes - Exit
 1597 0A81 23                      INC      HL          ; Next byte
 1598 0A82 FE22                    CP       '"'         ; Literal string?
 1599 0A84 CA790A                  JP       Z,NXTSTL    ; Yes - Look for anothe
 1600 0A87 C37C0A                  JP       NXTSTT      ; Keep looking
 1601                   ;
 1602 0A8A CD3F0F       LET:       CALL     GETVAR      ; Get variable name
 1603 0A8D CD5207                  CALL     CHKSYN      ; Make sure "=" follows
 1604 0A90 B4                      DB       ZEQUAL      ; "=" token
 1605 0A91 D5                      PUSH     DE          ; Save address of varia
 1606 0A92 3AF280                  LD       A,(TYPE)    ; Get data type
 1607 0A95 F5                      PUSH     AF          ; Save type
 1608 0A96 CD5B0D                  CALL     EVAL        ; Evaluate expression
 1609 0A99 F1                      POP      AF          ; Restore type
 1610 0A9A E3                      EX       (SP),HL     ; Save code - Get var a
 1611 0A9B 221381                  LD       (BRKLIN),HL ; Save address of varia
 1612 0A9E 1F                      RRA                  ; Adjust type
 1613 0A9F CD4E0D                  CALL     CHKTYP      ; Check types are the s
 1614 0AA2 CADD0A                  JP       Z,LETNUM    ; Numeric - Move value
 1615 0AA5 E5           LETSTR:    PUSH     HL          ; Save address of strin
 1616 0AA6 2A2981                  LD       HL,(FPREG)  ; Pointer to string ent
 1617 0AA9 E5                      PUSH     HL          ; Save it on stack
 1618 0AAA 23                      INC      HL          ; Skip over length
 1619 0AAB 23                      INC      HL
 1620 0AAC 5E                      LD       E,(HL)      ; LSB of string address
 1621 0AAD 23                      INC      HL
 1622 0AAE 56                      LD       D,(HL)      ; MSB of string address
 1623 0AAF 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1624 0AB2 CD4C07                  CALL     CPDEHL      ; Is string before prog
 1625 0AB5 D2CC0A                  JP       NC,CRESTR   ; Yes - Create string e
 1626 0AB8 2A9F80                  LD       HL,(STRSPC) ; Point to string space
 1627 0ABB CD4C07                  CALL     CPDEHL      ; Is string literal in 
 1628 0ABE D1                      POP      DE          ; Restore address of st
 1629 0ABF D2D40A                  JP       NC,MVSTPT   ; Yes - Set up pointer
 1630 0AC2 210481                  LD       HL,TMPSTR   ; Temporary string pool
 1631 0AC5 CD4C07                  CALL     CPDEHL      ; Is string in temporar
 1632 0AC8 D2D40A                  JP       NC,MVSTPT   ; No - Set up pointer
 1633 0ACB 3E                      DB       3EH         ; Skip "POP DE"
 1634 0ACC D1           CRESTR:    POP      DE          ; Restore address of st
 1635 0ACD CD8313                  CALL     BAKTMP      ; Back to last tmp-str 
 1636 0AD0 EB                      EX       DE,HL       ; Address of string ent
 1637 0AD1 CDBC11                  CALL     SAVSTR      ; Save string in string
 1638 0AD4 CD8313       MVSTPT:    CALL     BAKTMP      ; Back to last tmp-str 
 1639 0AD7 E1                      POP      HL          ; Get string pointer
 1640 0AD8 CD8617                  CALL     DETHL4      ; Move string pointer t
 1641 0ADB E1                      POP      HL          ; Restore code string a
 1642 0ADC C9                      RET
 1643                   ;
 1644 0ADD E5           LETNUM:    PUSH     HL          ; Save address of varia
 1645 0ADE CD8317                  CALL     FPTHL       ; Move value to variabl
 1646 0AE1 D1                      POP      DE          ; Restore address of va
 1647 0AE2 E1                      POP      HL          ; Restore code string a
 1648 0AE3 C9                      RET
 1649                   ;
 1650 0AE4 CDAA14       ON:        CALL     GETINT      ; Get integer 0-255
 1651 0AE7 7E                      LD       A,(HL)      ; Get "GOTO" or "GOSUB"
 1652 0AE8 47                      LD       B,A         ; Save in B
 1653 0AE9 FE8C                    CP       ZGOSUB      ; "GOSUB" token?
 1654 0AEB CAF30A                  JP       Z,ONGO      ; Yes - Find line numbe
 1655 0AEE CD5207                  CALL     CHKSYN      ; Make sure it's "GOTO"
 1656 0AF1 88                      DB       ZGOTO       ; "GOTO" token
 1657 0AF2 2B                      DEC      HL          ; Cancel increment
 1658 0AF3 4B           ONGO:      LD       C,E         ; Integer of branch val
 1659 0AF4 0D           ONGOLP:    DEC      C           ; Count branches
 1660 0AF5 78                      LD       A,B         ; Get "GOTO" or "GOSUB"
 1661 0AF6 CAC408                  JP       Z,ONJMP     ; Go to that line if ri
 1662 0AF9 CDA909                  CALL     GETLN       ; Get line number to DE
 1663 0AFC FE2C                    CP       ','         ; Another line number?
 1664 0AFE C0                      RET      NZ          ; No - Drop through
 1665 0AFF C3F40A                  JP       ONGOLP      ; Yes - loop
 1666                   ;
 1667 0B02 CD5B0D       IF:        CALL     EVAL        ; Evaluate expression
 1668 0B05 7E                      LD       A,(HL)      ; Get token
 1669 0B06 FE88                    CP       ZGOTO       ; "GOTO" token?
 1670 0B08 CA100B                  JP       Z,IFGO      ; Yes - Get line
 1671 0B0B CD5207                  CALL     CHKSYN      ; Make sure it's "THEN"
 1672 0B0E A9                      DB       ZTHEN       ; "THEN" token
 1673 0B0F 2B                      DEC      HL          ; Cancel increment
 1674 0B10 CD4C0D       IFGO:      CALL     TSTNUM      ; Make sure it's numeri
 1675 0B13 CD2B17                  CALL     TSTSGN      ; Test state of express
 1676 0B16 CA750A                  JP       Z,REM       ; False - Drop through
 1677 0B19 CDDC08                  CALL     GETCHR      ; Get next character
 1678 0B1C DA300A                  JP       C,GOTO      ; Number - GOTO that li
 1679 0B1F C3C308                  JP       IFJMP       ; Otherwise do statemen
 1680                   ;
 1681 0B22 2B           MRPRNT:    DEC      HL          ; DEC 'cos GETCHR INCs
 1682 0B23 CDDC08                  CALL     GETCHR      ; Get next character
 1683 0B26 CA840B       PRINT:     JP       Z,PRCRLF    ; CRLF if just PRINT
 1684 0B29 C8           PRNTLP:    RET      Z           ; End of list - Exit
 1685 0B2A FEA5                    CP       ZTAB        ; "TAB(" token?
 1686 0B2C CAB70B                  JP       Z,DOTAB     ; Yes - Do TAB routine
 1687 0B2F FEA8                    CP       ZSPC        ; "SPC(" token?
 1688 0B31 CAB70B                  JP       Z,DOTAB     ; Yes - Do SPC routine
 1689 0B34 E5                      PUSH     HL          ; Save code string addr
 1690 0B35 FE2C                    CP       ','         ; Comma?
 1691 0B37 CAA00B                  JP       Z,DOCOM     ; Yes - Move to next zo
 1692 0B3A FE3B                    CP       59          ;";"          ; Semi-co
 1693 0B3C CADA0B                  JP       Z,NEXITM    ; Do semi-colon routine
 1694 0B3F C1                      POP      BC          ; Code string address t
 1695 0B40 CD5B0D                  CALL     EVAL        ; Evaluate expression
 1696 0B43 E5                      PUSH     HL          ; Save code string addr
 1697 0B44 3AF280                  LD       A,(TYPE)    ; Get variable type
 1698 0B47 B7                      OR       A           ; Is it a string variab
 1699 0B48 C2700B                  JP       NZ,PRNTST   ; Yes - Output string c
 1700 0B4B CDD018                  CALL     NUMASC      ; Convert number to tex
 1701 0B4E CDE011                  CALL     CRTST       ; Create temporary stri
 1702 0B51 3620                    LD       (HL),' '    ; Followed by a space
 1703 0B53 2A2981                  LD       HL,(FPREG)  ; Get length of output
 1704 0B56 34                      INC      (HL)        ; Plus 1 for the space
 1705 0B57 2A2981                  LD       HL,(FPREG)  ; < Not needed >
 1706 0B5A 3A8780                  LD       A,(LWIDTH)  ; Get width of line
 1707 0B5D 47                      LD       B,A         ; To B
 1708 0B5E 04                      INC      B           ; Width 255 (No limit)?
 1709 0B5F CA6C0B                  JP       Z,PRNTNB    ; Yes - Output number s
 1710 0B62 04                      INC      B           ; Adjust it
 1711 0B63 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1712 0B66 86                      ADD      A,(HL)      ; Add length of string
 1713 0B67 3D                      DEC      A           ; Adjust it
 1714 0B68 B8                      CP       B           ; Will output fit on th
 1715 0B69 D4840B                  CALL     NC,PRCRLF   ; No - CRLF first
 1716 0B6C CD2512       PRNTNB:    CALL     PRS1        ; Output string at (HL)
 1717 0B6F AF                      XOR      A           ; Skip CALL by setting 
 1718 0B70 C42512       PRNTST:    CALL     NZ,PRS1     ; Output string at (HL)
 1719 0B73 E1                      POP      HL          ; Restore code string a
 1720 0B74 C3220B                  JP       MRPRNT      ; See if more to PRINT
 1721                   ;
 1722 0B77 3AF080       STTLIN:    LD       A,(CURPOS)  ; Make sure on new line
 1723 0B7A B7                      OR       A           ; Already at start?
 1724 0B7B C8                      RET      Z           ; Yes - Do nothing
 1725 0B7C C3840B                  JP       PRCRLF      ; Start a new line
 1726                   ;
 1727 0B7F 3600         ENDINP:    LD       (HL),0      ; Mark end of buffer
 1728 0B81 21A580                  LD       HL,BUFFER-1 ; Point to buffer
 1729 0B84 3E0D         PRCRLF:    LD       A,CR        ; Load a CR
 1730 0B86 CD5D07                  CALL     OUTC        ; Output character
 1731 0B89 3E0A                    LD       A,LF        ; Load a LF
 1732 0B8B CD5D07                  CALL     OUTC        ; Output character
 1733 0B8E AF           DONULL:    XOR      A           ; Set to position 0
 1734 0B8F 32F080                  LD       (CURPOS),A  ; Store it
 1735 0B92 3A8680                  LD       A,(NULLS)   ; Get number of nulls
 1736 0B95 3D           NULLP:     DEC      A           ; Count them
 1737 0B96 C8                      RET      Z           ; Return if done
 1738 0B97 F5                      PUSH     AF          ; Save count
 1739 0B98 AF                      XOR      A           ; Load a null
 1740 0B99 CD5D07                  CALL     OUTC        ; Output it
 1741 0B9C F1                      POP      AF          ; Restore count
 1742 0B9D C3950B                  JP       NULLP       ; Keep counting
 1743                   ;
 1744 0BA0 3A8880       DOCOM:     LD       A,(COMMAN)  ; Get comma width
 1745 0BA3 47                      LD       B,A         ; Save in B
 1746 0BA4 3AF080                  LD       A,(CURPOS)  ; Get current position
 1747 0BA7 B8                      CP       B           ; Within the limit?
 1748 0BA8 D4840B                  CALL     NC,PRCRLF   ; No - output CRLF
 1749 0BAB D2DA0B                  JP       NC,NEXITM   ; Get next item
 1750 0BAE D60E         ZONELP:    SUB      14          ; Next zone of 14 chara
 1751 0BB0 D2AE0B                  JP       NC,ZONELP   ; Repeat if more zones
 1752 0BB3 2F                      CPL                  ; Number of spaces to o
 1753 0BB4 C3CF0B                  JP       ASPCS       ; Output them
 1754                   ;
 1755 0BB7 F5           DOTAB:     PUSH     AF          ; Save token
 1756 0BB8 CDA714                  CALL     FNDNUM      ; Evaluate expression
 1757 0BBB CD5207                  CALL     CHKSYN      ; Make sure ")" follows
 1758 0BBE 29                      DB       ")"
 1759 0BBF 2B                      DEC      HL          ; Back space on to ")"
 1760 0BC0 F1                      POP      AF          ; Restore token
 1761 0BC1 D6A8                    SUB      ZSPC        ; Was it "SPC(" ?
 1762 0BC3 E5                      PUSH     HL          ; Save code string addr
 1763 0BC4 CACA0B                  JP       Z,DOSPC     ; Yes - Do 'E' spaces
 1764 0BC7 3AF080                  LD       A,(CURPOS)  ; Get current position
 1765 0BCA 2F           DOSPC:     CPL                  ; Number of spaces to p
 1766 0BCB 83                      ADD      A,E         ; Total number to print
 1767 0BCC D2DA0B                  JP       NC,NEXITM   ; TAB < Current POS(X)
 1768 0BCF 3C           ASPCS:     INC      A           ; Output A spaces
 1769 0BD0 47                      LD       B,A         ; Save number to print
 1770 0BD1 3E20                    LD       A,' '       ; Space
 1771 0BD3 CD5D07       SPCLP:     CALL     OUTC        ; Output character in A
 1772 0BD6 05                      DEC      B           ; Count them
 1773 0BD7 C2D30B                  JP       NZ,SPCLP    ; Repeat if more
 1774 0BDA E1           NEXITM:    POP      HL          ; Restore code string a
 1775 0BDB CDDC08                  CALL     GETCHR      ; Get next character
 1776 0BDE C3290B                  JP       PRNTLP      ; More to print
 1777                   ;
 1778 0BE1 3F5265646F20 REDO:      DB       "?Redo from start",CR,LF,0
           66726F6D2073 
           746172740D0A 
           00           
 1779                   ;
 1780 0BF4 3A1281       BADINP:    LD       A,(READFG)  ; READ or INPUT?
 1781 0BF7 B7                      OR       A
 1782 0BF8 C27E04                  JP       NZ,DATSNR   ; READ - ?SN Error
 1783 0BFB C1                      POP      BC          ; Throw away code strin
 1784 0BFC 21E10B                  LD       HL,REDO     ; "Redo from start" mes
 1785 0BFF CD2212                  CALL     PRS         ; Output string
 1786 0C02 C3CF05                  JP       DOAGN       ; Do last INPUT again
 1787                   ;
 1788 0C05 CD8D11       INPUT:     CALL     IDTEST      ; Test for illegal dire
 1789 0C08 7E                      LD       A,(HL)      ; Get character after "
 1790 0C09 FE22                    CP       '"'         ; Is there a prompt str
 1791 0C0B 3E00                    LD       A,0         ; Clear A and leave fla
 1792 0C0D 328A80                  LD       (CTLOFG),A  ; Enable output
 1793 0C10 C21F0C                  JP       NZ,NOPMPT   ; No prompt - get input
 1794 0C13 CDE111                  CALL     QTSTR       ; Get string terminated
 1795 0C16 CD5207                  CALL     CHKSYN      ; Check for ';' after p
 1796 0C19 3B                      DB       ';'
 1797 0C1A E5                      PUSH     HL          ; Save code string addr
 1798 0C1B CD2512                  CALL     PRS1        ; Output prompt string
 1799 0C1E 3E                      DB       3EH         ; Skip "PUSH HL"
 1800 0C1F E5           NOPMPT:    PUSH     HL          ; Save code string addr
 1801 0C20 CDD305                  CALL     PROMPT      ; Get input with "? " p
 1802 0C23 C1                      POP      BC          ; Restore code string a
 1803 0C24 DA2B09                  JP       C,INPBRK    ; Break pressed - Exit
 1804 0C27 23                      INC      HL          ; Next byte
 1805 0C28 7E                      LD       A,(HL)      ; Get it
 1806 0C29 B7                      OR       A           ; End of line?
 1807 0C2A 2B                      DEC      HL          ; Back again
 1808 0C2B C5                      PUSH     BC          ; Re-save code string a
 1809 0C2C CA720A                  JP       Z,NXTDTA    ; Yes - Find next DATA 
 1810 0C2F 362C                    LD       (HL),','    ; Store comma as separa
 1811 0C31 C3390C                  JP       NXTITM      ; Get next item
 1812                   ;
 1813 0C34 E5           READ:      PUSH     HL          ; Save code string addr
 1814 0C35 2A2181                  LD       HL,(NXTDAT) ; Next DATA statement
 1815 0C38 F6                      DB       0F6H        ; Flag "READ"
 1816 0C39 AF           NXTITM:    XOR      A           ; Flag "INPUT"
 1817 0C3A 321281                  LD       (READFG),A  ; Save "READ"/"INPUT" f
 1818 0C3D E3                      EX       (SP),HL     ; Get code str' , Save 
 1819 0C3E C3450C                  JP       GTVLUS      ; Get values
 1820                   ;
 1821 0C41 CD5207       NEDMOR:    CALL     CHKSYN      ; Check for comma betwe
 1822 0C44 2C                      DB       ','
 1823 0C45 CD3F0F       GTVLUS:    CALL     GETVAR      ; Get variable name
 1824 0C48 E3                      EX       (SP),HL     ; Save code str" , Get 
 1825 0C49 D5                      PUSH     DE          ; Save variable address
 1826 0C4A 7E                      LD       A,(HL)      ; Get next "INPUT"/"DAT
 1827 0C4B FE2C                    CP       ','         ; Comma?
 1828 0C4D CA6D0C                  JP       Z,ANTVLU    ; Yes - Get another val
 1829 0C50 3A1281                  LD       A,(READFG)  ; Is it READ?
 1830 0C53 B7                      OR       A
 1831 0C54 C2DA0C                  JP       NZ,FDTLP    ; Yes - Find next DATA 
 1832 0C57 3E3F                    LD       A,'?'       ; More INPUT needed
 1833 0C59 CD5D07                  CALL     OUTC        ; Output character
 1834 0C5C CDD305                  CALL     PROMPT      ; Get INPUT with prompt
 1835 0C5F D1                      POP      DE          ; Variable address
 1836 0C60 C1                      POP      BC          ; Code string address
 1837 0C61 DA2B09                  JP       C,INPBRK    ; Break pressed
 1838 0C64 23                      INC      HL          ; Point to next DATA by
 1839 0C65 7E                      LD       A,(HL)      ; Get byte
 1840 0C66 B7                      OR       A           ; Is it zero (No input)
 1841 0C67 2B                      DEC      HL          ; Back space INPUT poin
 1842 0C68 C5                      PUSH     BC          ; Save code string addr
 1843 0C69 CA720A                  JP       Z,NXTDTA    ; Find end of buffer
 1844 0C6C D5                      PUSH     DE          ; Save variable address
 1845 0C6D 3AF280       ANTVLU:    LD       A,(TYPE)    ; Check data type
 1846 0C70 B7                      OR       A           ; Is it numeric?
 1847 0C71 CA970C                  JP       Z,INPBIN    ; Yes - Convert to bina
 1848 0C74 CDDC08                  CALL     GETCHR      ; Get next character
 1849 0C77 57                      LD       D,A         ; Save input character
 1850 0C78 47                      LD       B,A         ; Again
 1851 0C79 FE22                    CP       '"'         ; Start of literal stin
 1852 0C7B CA8B0C                  JP       Z,STRENT    ; Yes - Create string e
 1853 0C7E 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1854 0C81 B7                      OR       A
 1855 0C82 57                      LD       D,A         ; Save 00 if "INPUT"
 1856 0C83 CA880C                  JP       Z,ITMSEP    ; "INPUT" - End with 00
 1857 0C86 163A                    LD       D,':'       ; "DATA" - End with 00 
 1858 0C88 062C         ITMSEP:    LD       B,','       ; Item separator
 1859 0C8A 2B                      DEC      HL          ; Back space for DTSTR
 1860 0C8B CDE411       STRENT:    CALL     DTSTR       ; Get string terminated
 1861 0C8E EB                      EX       DE,HL       ; String address to DE
 1862 0C8F 21A20C                  LD       HL,LTSTND   ; Where to go after LET
 1863 0C92 E3                      EX       (SP),HL     ; Save HL , get input p
 1864 0C93 D5                      PUSH     DE          ; Save address of strin
 1865 0C94 C3A50A                  JP       LETSTR      ; Assign string to vari
 1866                   ;
 1867 0C97 CDDC08       INPBIN:    CALL     GETCHR      ; Get next character
 1868 0C9A CD3218                  CALL     ASCTFP      ; Convert ASCII to FP n
 1869 0C9D E3                      EX       (SP),HL     ; Save input ptr, Get v
 1870 0C9E CD8317                  CALL     FPTHL       ; Move FPREG to variabl
 1871 0CA1 E1                      POP      HL          ; Restore input pointer
 1872 0CA2 2B           LTSTND:    DEC      HL          ; DEC 'cos GETCHR INCs
 1873 0CA3 CDDC08                  CALL     GETCHR      ; Get next character
 1874 0CA6 CAAE0C                  JP       Z,MORDT     ; End of line - More ne
 1875 0CA9 FE2C                    CP       ','         ; Another value?
 1876 0CAB C2F40B                  JP       NZ,BADINP   ; No - Bad input
 1877 0CAE E3           MORDT:     EX       (SP),HL     ; Get code string addre
 1878 0CAF 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 1879 0CB0 CDDC08                  CALL     GETCHR      ; Get next character
 1880 0CB3 C2410C                  JP       NZ,NEDMOR   ; More needed - Get it
 1881 0CB6 D1                      POP      DE          ; Restore DATA pointer
 1882 0CB7 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1883 0CBA B7                      OR       A
 1884 0CBB EB                      EX       DE,HL       ; DATA pointer to HL
 1885 0CBC C20209                  JP       NZ,UPDATA   ; Update DATA pointer i
 1886 0CBF D5                      PUSH     DE          ; Save code string addr
 1887 0CC0 B6                      OR       (HL)        ; More input given?
 1888 0CC1 21C90C                  LD       HL,EXTIG    ; "?Extra ignored" mess
 1889 0CC4 C42212                  CALL     NZ,PRS      ; Output string if extr
 1890 0CC7 E1                      POP      HL          ; Restore code string a
 1891 0CC8 C9                      RET
 1892                   ;
 1893 0CC9 3F4578747261 EXTIG:     DB       "?Extra ignored",CR,LF,0
           2069676E6F72 
           65640D0A00   
 1894                   ;
 1895 0CDA CD730A       FDTLP:     CALL     DATA        ; Get next statement
 1896 0CDD B7                      OR       A           ; End of line?
 1897 0CDE C2F30C                  JP       NZ,FANDT    ; No - See if DATA stat
 1898 0CE1 23                      INC      HL
 1899 0CE2 7E                      LD       A,(HL)      ; End of program?
 1900 0CE3 23                      INC      HL
 1901 0CE4 B6                      OR       (HL)        ; 00 00 Ends program
 1902 0CE5 1E06                    LD       E,OD        ; ?OD Error
 1903 0CE7 CA9804                  JP       Z,ERROR     ; Yes - Out of DATA
 1904 0CEA 23                      INC      HL
 1905 0CEB 5E                      LD       E,(HL)      ; LSB of line number
 1906 0CEC 23                      INC      HL
 1907 0CED 56                      LD       D,(HL)      ; MSB of line number
 1908 0CEE EB                      EX       DE,HL
 1909 0CEF 220E81                  LD       (DATLIN),HL ; Set line of current D
 1910 0CF2 EB                      EX       DE,HL
 1911 0CF3 CDDC08       FANDT:     CALL     GETCHR      ; Get next character
 1912 0CF6 FE83                    CP       ZDATA       ; "DATA" token
 1913 0CF8 C2DA0C                  JP       NZ,FDTLP    ; No "DATA" - Keep look
 1914 0CFB C36D0C                  JP       ANTVLU      ; Found - Convert input
 1915                   ;
 1916 0CFE 110000       NEXT:      LD       DE,0        ; In case no index give
 1917 0D01 C43F0F       NEXT1:     CALL     NZ,GETVAR   ; Get index address
 1918 0D04 221381                  LD       (BRKLIN),HL ; Save code string addr
 1919 0D07 CD2D04                  CALL     BAKSTK      ; Look for "FOR" block
 1920 0D0A C28A04                  JP       NZ,NFERR    ; No "FOR" - ?NF Error
 1921 0D0D F9                      LD       SP,HL       ; Clear nested loops
 1922 0D0E D5                      PUSH     DE          ; Save index address
 1923 0D0F 7E                      LD       A,(HL)      ; Get sign of STEP
 1924 0D10 23                      INC      HL
 1925 0D11 F5                      PUSH     AF          ; Save sign of STEP
 1926 0D12 D5                      PUSH     DE          ; Save index address
 1927 0D13 CD6917                  CALL     PHLTFP      ; Move index value to F
 1928 0D16 E3                      EX       (SP),HL     ; Save address of TO va
 1929 0D17 E5                      PUSH     HL          ; Save address of index
 1930 0D18 CDD614                  CALL     ADDPHL      ; Add STEP to index val
 1931 0D1B E1                      POP      HL          ; Restore address of in
 1932 0D1C CD8317                  CALL     FPTHL       ; Move value to index v
 1933 0D1F E1                      POP      HL          ; Restore address of TO
 1934 0D20 CD7A17                  CALL     LOADFP      ; Move TO value to BCDE
 1935 0D23 E5                      PUSH     HL          ; Save address of line 
 1936 0D24 CDA617                  CALL     CMPNUM      ; Compare index with TO
 1937 0D27 E1                      POP      HL          ; Restore address of li
 1938 0D28 C1                      POP      BC          ; Address of sign of ST
 1939 0D29 90                      SUB      B           ; Compare with expected
 1940 0D2A CD7A17                  CALL     LOADFP      ; BC = Loop stmt,DE = L
 1941 0D2D CA390D                  JP       Z,KILFOR    ; Loop finished - Termi
 1942 0D30 EB                      EX       DE,HL       ; Loop statement line n
 1943 0D31 22A180                  LD       (LINEAT),HL ; Set loop line number
 1944 0D34 69                      LD       L,C         ; Set code string to lo
 1945 0D35 60                      LD       H,B
 1946 0D36 C39808                  JP       PUTFID      ; Put back "FOR" and co
 1947                   ;
 1948 0D39 F9           KILFOR:    LD       SP,HL       ; Remove "FOR" block
 1949 0D3A 2A1381                  LD       HL,(BRKLIN) ; Code string after "NE
 1950 0D3D 7E                      LD       A,(HL)      ; Get next byte in code
 1951 0D3E FE2C                    CP       ','         ; More NEXTs ?
 1952 0D40 C29C08                  JP       NZ,RUNCNT   ; No - Do next statemen
 1953 0D43 CDDC08                  CALL     GETCHR      ; Position to index nam
 1954 0D46 CD010D                  CALL     NEXT1       ; Re-enter NEXT routine
 1955                   ; < will not RETurn to here , Exit to RUNCNT or Loop >
 1956                   ;
 1957 0D49 CD5B0D       GETNUM:    CALL     EVAL        ; Get a numeric express
 1958 0D4C F6           TSTNUM:    DB       0F6H        ; Clear carry (numeric)
 1959 0D4D 37           TSTSTR:    SCF                  ; Set carry (string)
 1960 0D4E 3AF280       CHKTYP:    LD       A,(TYPE)    ; Check types match
 1961 0D51 8F                      ADC      A,A         ; Expected + actual
 1962 0D52 B7                      OR       A           ; Clear carry , set par
 1963 0D53 E8                      RET      PE          ; Even parity - Types m
 1964 0D54 C39604                  JP       TMERR       ; Different types - Err
 1965                   ;
 1966 0D57 CD5207       OPNPAR:    CALL     CHKSYN      ; Make sure "(" follows
 1967 0D5A 28                      DB       "("
 1968 0D5B 2B           EVAL:      DEC      HL          ; Evaluate expression &
 1969 0D5C 1600                    LD       D,0         ; Precedence value
 1970 0D5E D5           EVAL1:     PUSH     DE          ; Save precedence
 1971 0D5F 0E01                    LD       C,1
 1972 0D61 CD6104                  CALL     CHKSTK      ; Check for 1 level of 
 1973 0D64 CDD20D                  CALL     OPRND       ; Get next expression v
 1974 0D67 221581       EVAL2:     LD       (NXTOPR),HL ; Save address of next 
 1975 0D6A 2A1581       EVAL3:     LD       HL,(NXTOPR) ; Restore address of ne
 1976 0D6D C1                      POP      BC          ; Precedence value and 
 1977 0D6E 78                      LD       A,B         ; Get precedence value
 1978 0D6F FE78                    CP       78H         ; "AND" or "OR" ?
 1979 0D71 D44C0D                  CALL     NC,TSTNUM   ; No - Make sure it's a
 1980 0D74 7E                      LD       A,(HL)      ; Get next operator / f
 1981 0D75 1600                    LD       D,0         ; Clear Last relation
 1982 0D77 D6B3         RLTLP:     SUB      ZGTR        ; ">" Token
 1983 0D79 DA930D                  JP       C,FOPRND    ; + - * / ^ AND OR - Te
 1984 0D7C FE03                    CP       ZLTH+1-ZGTR ; < = >
 1985 0D7E D2930D                  JP       NC,FOPRND   ; Function - Call it
 1986 0D81 FE01                    CP       ZEQUAL-ZGTR ; "="
 1987 0D83 17                      RLA                  ; <- Test for legal
 1988 0D84 AA                      XOR      D           ; <- combinations of < 
 1989 0D85 BA                      CP       D           ; <- by combining last 
 1990 0D86 57                      LD       D,A         ; <- with current one
 1991 0D87 DA8404                  JP       C,SNERR     ; Error if "<<' '==" or
 1992 0D8A 220A81                  LD       (CUROPR),HL ; Save address of curre
 1993 0D8D CDDC08                  CALL     GETCHR      ; Get next character
 1994 0D90 C3770D                  JP       RLTLP       ; Treat the two as one
 1995                   ;
 1996 0D93 7A           FOPRND:    LD       A,D         ; < = > found ?
 1997 0D94 B7                      OR       A
 1998 0D95 C2BA0E                  JP       NZ,TSTRED   ; Yes - Test for reduct
 1999 0D98 7E                      LD       A,(HL)      ; Get operator token
 2000 0D99 220A81                  LD       (CUROPR),HL ; Save operator address
 2001 0D9C D6AC                    SUB      ZPLUS       ; Operator or function?
 2002 0D9E D8                      RET      C           ; Neither - Exit
 2003 0D9F FE07                    CP       ZOR+1-ZPLUS ; Is it + - * / ^ AND O
 2004 0DA1 D0                      RET      NC          ; No - Exit
 2005 0DA2 5F                      LD       E,A         ; Coded operator
 2006 0DA3 3AF280                  LD       A,(TYPE)    ; Get data type
 2007 0DA6 3D                      DEC      A           ; FF = numeric , 00 = s
 2008 0DA7 B3                      OR       E           ; Combine with coded op
 2009 0DA8 7B                      LD       A,E         ; Get coded operator
 2010 0DA9 CA1813                  JP       Z,CONCAT    ; String concatenation
 2011 0DAC 07                      RLCA                 ; Times 2
 2012 0DAD 83                      ADD      A,E         ; Times 3
 2013 0DAE 5F                      LD       E,A         ; To DE (D is 0)
 2014 0DAF 217603                  LD       HL,PRITAB   ; Precedence table
 2015 0DB2 19                      ADD      HL,DE       ; To the operator conce
 2016 0DB3 78                      LD       A,B         ; Last operator precede
 2017 0DB4 56                      LD       D,(HL)      ; Get evaluation preced
 2018 0DB5 BA                      CP       D           ; Compare with eval pre
 2019 0DB6 D0                      RET      NC          ; Exit if higher preced
 2020 0DB7 23                      INC      HL          ; Point to routine addr
 2021 0DB8 CD4C0D                  CALL     TSTNUM      ; Make sure it's a numb
 2022                   ;
 2023 0DBB C5           STKTHS:    PUSH     BC          ; Save last precedence 
 2024 0DBC 016A0D                  LD       BC,EVAL3    ; Where to go on prec' 
 2025 0DBF C5                      PUSH     BC          ; Save on stack for ret
 2026 0DC0 43                      LD       B,E         ; Save operator
 2027 0DC1 4A                      LD       C,D         ; Save precedence
 2028 0DC2 CD5C17                  CALL     STAKFP      ; Move value to stack
 2029 0DC5 58                      LD       E,B         ; Restore operator
 2030 0DC6 51                      LD       D,C         ; Restore precedence
 2031 0DC7 4E                      LD       C,(HL)      ; Get LSB of routine ad
 2032 0DC8 23                      INC      HL
 2033 0DC9 46                      LD       B,(HL)      ; Get MSB of routine ad
 2034 0DCA 23                      INC      HL
 2035 0DCB C5                      PUSH     BC          ; Save routine address
 2036 0DCC 2A0A81                  LD       HL,(CUROPR) ; Address of current op
 2037 0DCF C35E0D                  JP       EVAL1       ; Loop until prec' brea
 2038                   ;
 2039 0DD2 AF           OPRND:     XOR      A           ; Get operand routine
 2040 0DD3 32F280                  LD       (TYPE),A    ; Set numeric expected
 2041 0DD6 CDDC08                  CALL     GETCHR      ; Get next character
 2042 0DD9 1E24                    LD       E,MO        ; ?MO Error
 2043 0DDB CA9804                  JP       Z,ERROR     ; No operand - Error
 2044 0DDE DA3218                  JP       C,ASCTFP    ; Number - Get value
 2045 0DE1 CD7A09                  CALL     CHKLTR      ; See if a letter
 2046 0DE4 D2390E                  JP       NC,CONVAR   ; Letter - Find variabl
 2047 0DE7 FE26                    CP       '&'         ; &H = HEX, &B = BINARY
 2048 0DE9 2012                    JR       NZ, NOTAMP
 2049 0DEB CDDC08                  CALL     GETCHR      ; Get next character
 2050 0DEE FE48                    CP       'H'         ; Hex number indicated?
 2051 0DF0 CA761C                  JP       Z,HEXTFP    ; Convert Hex to FPREG
 2052 0DF3 FE42                    CP       'B'         ; Binary number indicat
 2053 0DF5 CAE61C                  JP       Z,BINTFP    ; Convert Bin to FPREG
 2054 0DF8 1E02                    LD       E,SN        ; If neither then a ?SN
 2055 0DFA CA9804                  JP       Z,ERROR
 2056 0DFD FEAC         NOTAMP:    CP       ZPLUS       ; '+' Token ?
 2057 0DFF CAD20D                  JP       Z,OPRND     ; Yes - Look for operan
 2058 0E02 FE2E                    CP       '.'         ; '.' ?
 2059 0E04 CA3218                  JP       Z,ASCTFP    ; Yes - Create FP numbe
 2060 0E07 FEAD                    CP       ZMINUS      ; '-' Token ?
 2061 0E09 CA280E                  JP       Z,MINUS     ; Yes - Do minus
 2062 0E0C FE22                    CP       '"'         ; Literal string ?
 2063 0E0E CAE111                  JP       Z,QTSTR     ; Get string terminated
 2064 0E11 FEAA                    CP       ZNOT        ; "NOT" Token ?
 2065 0E13 CA1A0F                  JP       Z,EVNOT     ; Yes - Eval NOT expres
 2066 0E16 FEA7                    CP       ZFN         ; "FN" Token ?
 2067 0E18 CA4511                  JP       Z,DOFN      ; Yes - Do FN routine
 2068 0E1B D6B6                    SUB      ZSGN        ; Is it a function?
 2069 0E1D D24A0E                  JP       NC,FNOFST   ; Yes - Evaluate functi
 2070 0E20 CD570D       EVLPAR:    CALL     OPNPAR      ; Evaluate expression i
 2071 0E23 CD5207                  CALL     CHKSYN      ; Make sure ")" follows
 2072 0E26 29                      DB       ")"
 2073 0E27 C9                      RET
 2074                   ;
 2075 0E28 167D         MINUS:     LD       D,7DH       ; '-' precedence
 2076 0E2A CD5E0D                  CALL     EVAL1       ; Evaluate until prec' 
 2077 0E2D 2A1581                  LD       HL,(NXTOPR) ; Get next operator add
 2078 0E30 E5                      PUSH     HL          ; Save next operator ad
 2079 0E31 CD5417                  CALL     INVSGN      ; Negate value
 2080 0E34 CD4C0D       RETNUM:    CALL     TSTNUM      ; Make sure it's a numb
 2081 0E37 E1                      POP      HL          ; Restore next operator
 2082 0E38 C9                      RET
 2083                   ;
 2084 0E39 CD3F0F       CONVAR:    CALL     GETVAR      ; Get variable address 
 2085 0E3C E5           FRMEVL:    PUSH     HL          ; Save code string addr
 2086 0E3D EB                      EX       DE,HL       ; Variable address to H
 2087 0E3E 222981                  LD       (FPREG),HL  ; Save address of varia
 2088 0E41 3AF280                  LD       A,(TYPE)    ; Get type
 2089 0E44 B7                      OR       A           ; Numeric?
 2090 0E45 CC6917                  CALL     Z,PHLTFP    ; Yes - Move contents t
 2091 0E48 E1                      POP      HL          ; Restore code string a
 2092 0E49 C9                      RET
 2093                   ;
 2094 0E4A 0600         FNOFST:    LD       B,0         ; Get address of functi
 2095 0E4C 07                      RLCA                 ; Double function offse
 2096 0E4D 4F                      LD       C,A         ; BC = Offset in functi
 2097 0E4E C5                      PUSH     BC          ; Save adjusted token v
 2098 0E4F CDDC08                  CALL     GETCHR      ; Get next character
 2099 0E52 79                      LD       A,C         ; Get adjusted token va
 2100 0E53 FE31                    CP       2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT
 2101 0E55 DA710E                  JP       C,FNVAL     ; No - Do function
 2102 0E58 CD570D                  CALL     OPNPAR      ; Evaluate expression  
 2103 0E5B CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 2104 0E5E 2C                      DB       ','
 2105 0E5F CD4D0D                  CALL     TSTSTR      ; Make sure it's a stri
 2106 0E62 EB                      EX       DE,HL       ; Save code string addr
 2107 0E63 2A2981                  LD       HL,(FPREG)  ; Get address of string
 2108 0E66 E3                      EX       (SP),HL     ; Save address of strin
 2109 0E67 E5                      PUSH     HL          ; Save adjusted token v
 2110 0E68 EB                      EX       DE,HL       ; Restore code string a
 2111 0E69 CDAA14                  CALL     GETINT      ; Get integer 0-255
 2112 0E6C EB                      EX       DE,HL       ; Save code string addr
 2113 0E6D E3                      EX       (SP),HL     ; Save integer,HL = adj
 2114 0E6E C3790E                  JP       GOFUNC      ; Jump to string functi
 2115                   ;
 2116 0E71 CD200E       FNVAL:     CALL     EVLPAR      ; Evaluate expression
 2117 0E74 E3                      EX       (SP),HL     ; HL = Adjusted token v
 2118 0E75 11340E                  LD       DE,RETNUM   ; Return number from fu
 2119 0E78 D5                      PUSH     DE          ; Save on stack
 2120 0E79 01D501       GOFUNC:    LD       BC,FNCTAB   ; Function routine addr
 2121 0E7C 09                      ADD      HL,BC       ; Point to right addres
 2122 0E7D 4E                      LD       C,(HL)      ; Get LSB of address
 2123 0E7E 23                      INC      HL          ;
 2124 0E7F 66                      LD       H,(HL)      ; Get MSB of address
 2125 0E80 69                      LD       L,C         ; Address to HL
 2126 0E81 E9                      JP       (HL)        ; Jump to function
 2127                   ;
 2128 0E82 15           SGNEXP:    DEC      D           ; Dee to flag negative 
 2129 0E83 FEAD                    CP       ZMINUS      ; '-' token ?
 2130 0E85 C8                      RET      Z           ; Yes - Return
 2131 0E86 FE2D                    CP       '-'         ; '-' ASCII ?
 2132 0E88 C8                      RET      Z           ; Yes - Return
 2133 0E89 14                      INC      D           ; Inc to flag positive 
 2134 0E8A FE2B                    CP       '+'         ; '+' ASCII ?
 2135 0E8C C8                      RET      Z           ; Yes - Return
 2136 0E8D FEAC                    CP       ZPLUS       ; '+' token ?
 2137 0E8F C8                      RET      Z           ; Yes - Return
 2138 0E90 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2139 0E91 C9                      RET                  ; Return "NZ"
 2140                   ;
 2141 0E92 F6           POR:       DB       0F6H        ; Flag "OR"
 2142 0E93 AF           PAND:      XOR      A           ; Flag "AND"
 2143 0E94 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2144 0E95 CD4C0D                  CALL     TSTNUM      ; Make sure it's a numb
 2145 0E98 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 2146 0E9B F1                      POP      AF          ; Restore "AND" / "OR" 
 2147 0E9C EB                      EX       DE,HL       ; <- Get last
 2148 0E9D C1                      POP      BC          ; <- value
 2149 0E9E E3                      EX       (SP),HL     ; <- from
 2150 0E9F EB                      EX       DE,HL       ; <- stack
 2151 0EA0 CD6C17                  CALL     FPBCDE      ; Move last value to FP
 2152 0EA3 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2153 0EA4 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 2154 0EA7 F1                      POP      AF          ; Restore "AND" / "OR" 
 2155 0EA8 C1                      POP      BC          ; Get value
 2156 0EA9 79                      LD       A,C         ; Get LSB
 2157 0EAA 210311                  LD       HL,ACPASS   ; Address of save AC as
 2158 0EAD C2B50E                  JP       NZ,POR1     ; Jump if OR
 2159 0EB0 A3                      AND      E           ; "AND" LSBs
 2160 0EB1 4F                      LD       C,A         ; Save LSB
 2161 0EB2 78                      LD       A,B         ; Get MBS
 2162 0EB3 A2                      AND      D           ; "AND" MSBs
 2163 0EB4 E9                      JP       (HL)        ; Save AC as current (A
 2164                   ;
 2165 0EB5 B3           POR1:      OR       E           ; "OR" LSBs
 2166 0EB6 4F                      LD       C,A         ; Save LSB
 2167 0EB7 78                      LD       A,B         ; Get MSB
 2168 0EB8 B2                      OR       D           ; "OR" MSBs
 2169 0EB9 E9                      JP       (HL)        ; Save AC as current (A
 2170                   ;
 2171 0EBA 21CC0E       TSTRED:    LD       HL,CMPLOG   ; Logical compare routi
 2172 0EBD 3AF280                  LD       A,(TYPE)    ; Get data type
 2173 0EC0 1F                      RRA                  ; Carry set = string
 2174 0EC1 7A                      LD       A,D         ; Get last precedence v
 2175 0EC2 17                      RLA                  ; Times 2 plus carry
 2176 0EC3 5F                      LD       E,A         ; To E
 2177 0EC4 1664                    LD       D,64H       ; Relational precedence
 2178 0EC6 78                      LD       A,B         ; Get current precedenc
 2179 0EC7 BA                      CP       D           ; Compare with last
 2180 0EC8 D0                      RET      NC          ; Eval if last was rel'
 2181 0EC9 C3BB0D                  JP       STKTHS      ; Stack this one and ge
 2182                   ;
 2183 0ECC CE0E         CMPLOG:    DW       CMPLG1      ; Compare two values / 
 2184 0ECE 79           CMPLG1:    LD       A,C         ; Get data type
 2185 0ECF B7                      OR       A
 2186 0ED0 1F                      RRA
 2187 0ED1 C1                      POP      BC          ; Get last expression t
 2188 0ED2 D1                      POP      DE
 2189 0ED3 F5                      PUSH     AF          ; Save status
 2190 0ED4 CD4E0D                  CALL     CHKTYP      ; Check that types matc
 2191 0ED7 21100F                  LD       HL,CMPRES   ; Result to comparison
 2192 0EDA E5                      PUSH     HL          ; Save for RETurn
 2193 0EDB CAA617                  JP       Z,CMPNUM    ; Compare values if num
 2194 0EDE AF                      XOR      A           ; Compare two strings
 2195 0EDF 32F280                  LD       (TYPE),A    ; Set type to numeric
 2196 0EE2 D5                      PUSH     DE          ; Save string name
 2197 0EE3 CD6513                  CALL     GSTRCU      ; Get current string
 2198 0EE6 7E                      LD       A,(HL)      ; Get length of string
 2199 0EE7 23                      INC      HL
 2200 0EE8 23                      INC      HL
 2201 0EE9 4E                      LD       C,(HL)      ; Get LSB of address
 2202 0EEA 23                      INC      HL
 2203 0EEB 46                      LD       B,(HL)      ; Get MSB of address
 2204 0EEC D1                      POP      DE          ; Restore string name
 2205 0EED C5                      PUSH     BC          ; Save address of strin
 2206 0EEE F5                      PUSH     AF          ; Save length of string
 2207 0EEF CD6913                  CALL     GSTRDE      ; Get second string
 2208 0EF2 CD7A17                  CALL     LOADFP      ; Get address of second
 2209 0EF5 F1                      POP      AF          ; Restore length of str
 2210 0EF6 57                      LD       D,A         ; Length to D
 2211 0EF7 E1                      POP      HL          ; Restore address of st
 2212 0EF8 7B           CMPSTR:    LD       A,E         ; Bytes of string 2 to 
 2213 0EF9 B2                      OR       D           ; Bytes of string 1 to 
 2214 0EFA C8                      RET      Z           ; Exit if all bytes com
 2215 0EFB 7A                      LD       A,D         ; Get bytes of string 1
 2216 0EFC D601                    SUB      1
 2217 0EFE D8                      RET      C           ; Exit if end of string
 2218 0EFF AF                      XOR      A
 2219 0F00 BB                      CP       E           ; Bytes of string 2 to 
 2220 0F01 3C                      INC      A
 2221 0F02 D0                      RET      NC          ; Exit if end of string
 2222 0F03 15                      DEC      D           ; Count bytes in string
 2223 0F04 1D                      DEC      E           ; Count bytes in string
 2224 0F05 0A                      LD       A,(BC)      ; Byte in string 2
 2225 0F06 BE                      CP       (HL)        ; Compare to byte in st
 2226 0F07 23                      INC      HL          ; Move up string 1
 2227 0F08 03                      INC      BC          ; Move up string 2
 2228 0F09 CAF80E                  JP       Z,CMPSTR    ; Same - Try next bytes
 2229 0F0C 3F                      CCF                  ; Flag difference (">" 
 2230 0F0D C33617                  JP       FLGDIF      ; "<" gives -1 , ">" gi
 2231                   ;
 2232 0F10 3C           CMPRES:    INC      A           ; Increment current val
 2233 0F11 8F                      ADC      A,A         ; Double plus carry
 2234 0F12 C1                      POP      BC          ; Get other value
 2235 0F13 A0                      AND      B           ; Combine them
 2236 0F14 C6FF                    ADD      A,-1        ; Carry set if differen
 2237 0F16 9F                      SBC      A,A         ; 00 - Equal , FF - Dif
 2238 0F17 C33D17                  JP       FLGREL      ; Set current value & c
 2239                   ;
 2240 0F1A 165A         EVNOT:     LD       D,5AH       ; Precedence value for 
 2241 0F1C CD5E0D                  CALL     EVAL1       ; Eval until precedence
 2242 0F1F CD4C0D                  CALL     TSTNUM      ; Make sure it's a numb
 2243 0F22 CD8E09                  CALL     DEINT       ; Get integer -32768 - 
 2244 0F25 7B                      LD       A,E         ; Get LSB
 2245 0F26 2F                      CPL                  ; Invert LSB
 2246 0F27 4F                      LD       C,A         ; Save "NOT" of LSB
 2247 0F28 7A                      LD       A,D         ; Get MSB
 2248 0F29 2F                      CPL                  ; Invert MSB
 2249 0F2A CD0311                  CALL     ACPASS      ; Save AC as current
 2250 0F2D C1                      POP      BC          ; Clean up stack
 2251 0F2E C36A0D                  JP       EVAL3       ; Continue evaluation
 2252                   ;
 2253 0F31 2B           DIMRET:    DEC      HL          ; DEC 'cos GETCHR INCs
 2254 0F32 CDDC08                  CALL     GETCHR      ; Get next character
 2255 0F35 C8                      RET      Z           ; End of DIM statement
 2256 0F36 CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 2257 0F39 2C                      DB       ','
 2258 0F3A 01310F       DIM:       LD       BC,DIMRET   ; Return to "DIMRET"
 2259 0F3D C5                      PUSH     BC          ; Save on stack
 2260 0F3E F6                      DB       0F6H        ; Flag "Create" variabl
 2261 0F3F AF           GETVAR:    XOR      A           ; Find variable address
 2262 0F40 32F180                  LD       (LCRFLG),A  ; Set locate / create f
 2263 0F43 46                      LD       B,(HL)      ; Get First byte of nam
 2264 0F44 CD7A09       GTFNAM:    CALL     CHKLTR      ; See if a letter
 2265 0F47 DA8404                  JP       C,SNERR     ; ?SN Error if not a le
 2266 0F4A AF                      XOR      A
 2267 0F4B 4F                      LD       C,A         ; Clear second byte of 
 2268 0F4C 32F280                  LD       (TYPE),A    ; Set type to numeric
 2269 0F4F CDDC08                  CALL     GETCHR      ; Get next character
 2270 0F52 DA5B0F                  JP       C,SVNAM2    ; Numeric - Save in nam
 2271 0F55 CD7A09                  CALL     CHKLTR      ; See if a letter
 2272 0F58 DA680F                  JP       C,CHARTY    ; Not a letter - Check 
 2273 0F5B 4F           SVNAM2:    LD       C,A         ; Save second byte of n
 2274 0F5C CDDC08       ENDNAM:    CALL     GETCHR      ; Get next character
 2275 0F5F DA5C0F                  JP       C,ENDNAM    ; Numeric - Get another
 2276 0F62 CD7A09                  CALL     CHKLTR      ; See if a letter
 2277 0F65 D25C0F                  JP       NC,ENDNAM   ; Letter - Get another
 2278 0F68 D624         CHARTY:    SUB      '$'         ; String variable?
 2279 0F6A C2770F                  JP       NZ,NOTSTR   ; No - Numeric variable
 2280 0F6D 3C                      INC      A           ; A = 1 (string type)
 2281 0F6E 32F280                  LD       (TYPE),A    ; Set type to string
 2282 0F71 0F                      RRCA                 ; A = 80H , Flag for st
 2283 0F72 81                      ADD      A,C         ; 2nd byte of name has 
 2284 0F73 4F                      LD       C,A         ; Resave second byte on
 2285 0F74 CDDC08                  CALL     GETCHR      ; Get next character
 2286 0F77 3A1081       NOTSTR:    LD       A,(FORFLG)  ; Array name needed ?
 2287 0F7A 3D                      DEC      A
 2288 0F7B CA2410                  JP       Z,ARLDSV    ; Yes - Get array name
 2289 0F7E F2870F                  JP       P,NSCFOR    ; No array with "FOR" o
 2290 0F81 7E                      LD       A,(HL)      ; Get byte again
 2291 0F82 D628                    SUB      '('         ; Subscripted variable?
 2292 0F84 CAFC0F                  JP       Z,SBSCPT    ; Yes - Sort out subscr
 2293                   ;
 2294 0F87 AF           NSCFOR:    XOR      A           ; Simple variable
 2295 0F88 321081                  LD       (FORFLG),A  ; Clear "FOR" flag
 2296 0F8B E5                      PUSH     HL          ; Save code string addr
 2297 0F8C 50                      LD       D,B         ; DE = Variable name to
 2298 0F8D 59                      LD       E,C
 2299 0F8E 2A2381                  LD       HL,(FNRGNM) ; FN argument name
 2300 0F91 CD4C07                  CALL     CPDEHL      ; Is it the FN argument
 2301 0F94 112581                  LD       DE,FNARG    ; Point to argument val
 2302 0F97 CA6C16                  JP       Z,POPHRT    ; Yes - Return FN argum
 2303 0F9A 2A1D81                  LD       HL,(VAREND) ; End of variables
 2304 0F9D EB                      EX       DE,HL       ; Address of end of sea
 2305 0F9E 2A1B81                  LD       HL,(PROGND) ; Start of variables ad
 2306 0FA1 CD4C07       FNDVAR:    CALL     CPDEHL      ; End of variable list 
 2307 0FA4 CABA0F                  JP       Z,CFEVAL    ; Yes - Called from EVA
 2308 0FA7 79                      LD       A,C         ; Get second byte of na
 2309 0FA8 96                      SUB      (HL)        ; Compare with name in 
 2310 0FA9 23                      INC      HL          ; Move on to first byte
 2311 0FAA C2AF0F                  JP       NZ,FNTHR    ; Different - Find anot
 2312 0FAD 78                      LD       A,B         ; Get first byte of nam
 2313 0FAE 96                      SUB      (HL)        ; Compare with name in 
 2314 0FAF 23           FNTHR:     INC      HL          ; Move on to LSB of val
 2315 0FB0 CAEE0F                  JP       Z,RETADR    ; Found - Return addres
 2316 0FB3 23                      INC      HL          ; <- Skip
 2317 0FB4 23                      INC      HL          ; <- over
 2318 0FB5 23                      INC      HL          ; <- F.P.
 2319 0FB6 23                      INC      HL          ; <- value
 2320 0FB7 C3A10F                  JP       FNDVAR      ; Keep looking
 2321                   ;
 2322 0FBA E1           CFEVAL:    POP      HL          ; Restore code string a
 2323 0FBB E3                      EX       (SP),HL     ; Get return address
 2324 0FBC D5                      PUSH     DE          ; Save address of varia
 2325 0FBD 113C0E                  LD       DE,FRMEVL   ; Return address in EVA
 2326 0FC0 CD4C07                  CALL     CPDEHL      ; Called from EVAL ?
 2327 0FC3 D1                      POP      DE          ; Restore address of va
 2328 0FC4 CAF10F                  JP       Z,RETNUL    ; Yes - Return null var
 2329 0FC7 E3                      EX       (SP),HL     ; Put back return
 2330 0FC8 E5                      PUSH     HL          ; Save code string addr
 2331 0FC9 C5                      PUSH     BC          ; Save variable name
 2332 0FCA 010600                  LD       BC,6        ; 2 byte name plus 4 by
 2333 0FCD 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2334 0FD0 E5                      PUSH     HL          ; Save end of arrays
 2335 0FD1 09                      ADD      HL,BC       ; Move up 6 bytes
 2336 0FD2 C1                      POP      BC          ; Source address in BC
 2337 0FD3 E5                      PUSH     HL          ; Save new end address
 2338 0FD4 CD5004                  CALL     MOVUP       ; Move arrays up
 2339 0FD7 E1                      POP      HL          ; Restore new end addre
 2340 0FD8 221F81                  LD       (ARREND),HL ; Set new end address
 2341 0FDB 60                      LD       H,B         ; End of variables to H
 2342 0FDC 69                      LD       L,C
 2343 0FDD 221D81                  LD       (VAREND),HL ; Set new end address
 2344                   ;
 2345 0FE0 2B           ZEROLP:    DEC      HL          ; Back through to zero 
 2346 0FE1 3600                    LD       (HL),0      ; Zero byte in variable
 2347 0FE3 CD4C07                  CALL     CPDEHL      ; Done them all?
 2348 0FE6 C2E00F                  JP       NZ,ZEROLP   ; No - Keep on going
 2349 0FE9 D1                      POP      DE          ; Get variable name
 2350 0FEA 73                      LD       (HL),E      ; Store second characte
 2351 0FEB 23                      INC      HL
 2352 0FEC 72                      LD       (HL),D      ; Store first character
 2353 0FED 23                      INC      HL
 2354 0FEE EB           RETADR:    EX       DE,HL       ; Address of variable i
 2355 0FEF E1                      POP      HL          ; Restore code string a
 2356 0FF0 C9                      RET
 2357                   ;
 2358 0FF1 322C81       RETNUL:    LD       (FPEXP),A   ; Set result to zero
 2359 0FF4 212004                  LD       HL,ZERBYT   ; Also set a null strin
 2360 0FF7 222981                  LD       (FPREG),HL  ; Save for EVAL
 2361 0FFA E1                      POP      HL          ; Restore code string a
 2362 0FFB C9                      RET
 2363                   ;
 2364 0FFC E5           SBSCPT:    PUSH     HL          ; Save code string addr
 2365 0FFD 2AF180                  LD       HL,(LCRFLG) ; Locate/Create and Typ
 2366 1000 E3                      EX       (SP),HL     ; Save and get code str
 2367 1001 57                      LD       D,A         ; Zero number of dimens
 2368 1002 D5           SCPTLP:    PUSH     DE          ; Save number of dimens
 2369 1003 C5                      PUSH     BC          ; Save array name
 2370 1004 CD8209                  CALL     FPSINT      ; Get subscript (0-3276
 2371 1007 C1                      POP      BC          ; Restore array name
 2372 1008 F1                      POP      AF          ; Get number of dimensi
 2373 1009 EB                      EX       DE,HL
 2374 100A E3                      EX       (SP),HL     ; Save subscript value
 2375 100B E5                      PUSH     HL          ; Save LCRFLG and TYPE
 2376 100C EB                      EX       DE,HL
 2377 100D 3C                      INC      A           ; Count dimensions
 2378 100E 57                      LD       D,A         ; Save in D
 2379 100F 7E                      LD       A,(HL)      ; Get next byte in code
 2380 1010 FE2C                    CP       ','         ; Comma (more to come)?
 2381 1012 CA0210                  JP       Z,SCPTLP    ; Yes - More subscripts
 2382 1015 CD5207                  CALL     CHKSYN      ; Make sure ")" follows
 2383 1018 29                      DB       ")"
 2384 1019 221581                  LD       (NXTOPR),HL ; Save code string addr
 2385 101C E1                      POP      HL          ; Get LCRFLG and TYPE
 2386 101D 22F180                  LD       (LCRFLG),HL ; Restore Locate/create
 2387 1020 1E00                    LD       E,0         ; Flag not CSAVE* or CL
 2388 1022 D5                      PUSH     DE          ; Save number of dimens
 2389 1023 11                      DB       11H         ; Skip "PUSH HL" and "P
 2390                   ;
 2391 1024 E5           ARLDSV:    PUSH     HL          ; Save code string addr
 2392 1025 F5                      PUSH     AF          ; A = 00 , Flags set = 
 2393 1026 2A1D81                  LD       HL,(VAREND) ; Start of arrays
 2394 1029 3E                      DB       3EH         ; Skip "ADD HL,DE"
 2395 102A 19           FNDARY:    ADD      HL,DE       ; Move to next array st
 2396 102B EB                      EX       DE,HL
 2397 102C 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2398 102F EB                      EX       DE,HL       ; Current array pointer
 2399 1030 CD4C07                  CALL     CPDEHL      ; End of arrays found?
 2400 1033 CA5C10                  JP       Z,CREARY    ; Yes - Create array
 2401 1036 7E                      LD       A,(HL)      ; Get second byte of na
 2402 1037 B9                      CP       C           ; Compare with name giv
 2403 1038 23                      INC      HL          ; Move on
 2404 1039 C23E10                  JP       NZ,NXTARY   ; Different - Find next
 2405 103C 7E                      LD       A,(HL)      ; Get first byte of nam
 2406 103D B8                      CP       B           ; Compare with name giv
 2407 103E 23           NXTARY:    INC      HL          ; Move on
 2408 103F 5E                      LD       E,(HL)      ; Get LSB of next array
 2409 1040 23                      INC      HL
 2410 1041 56                      LD       D,(HL)      ; Get MSB of next array
 2411 1042 23                      INC      HL
 2412 1043 C22A10                  JP       NZ,FNDARY   ; Not found - Keep look
 2413 1046 3AF180                  LD       A,(LCRFLG)  ; Found Locate or Creat
 2414 1049 B7                      OR       A
 2415 104A C28D04                  JP       NZ,DDERR    ; Create - ?DD Error
 2416 104D F1                      POP      AF          ; Locate - Get number o
 2417 104E 44                      LD       B,H         ; BC Points to array di
 2418 104F 4D                      LD       C,L
 2419 1050 CA6C16                  JP       Z,POPHRT    ; Jump if array load/sa
 2420 1053 96                      SUB      (HL)        ; Same number of dimens
 2421 1054 CABA10                  JP       Z,FINDEL    ; Yes - Find element
 2422 1057 1E10         BSERR:     LD       E,BS        ; ?BS Error
 2423 1059 C39804                  JP       ERROR       ; Output error
 2424                   ;
 2425 105C 110400       CREARY:    LD       DE,4        ; 4 Bytes per entry
 2426 105F F1                      POP      AF          ; Array to save or 0 di
 2427 1060 CAA309                  JP       Z,FCERR     ; Yes - ?FC Error
 2428 1063 71                      LD       (HL),C      ; Save second byte of n
 2429 1064 23                      INC      HL
 2430 1065 70                      LD       (HL),B      ; Save first byte of na
 2431 1066 23                      INC      HL
 2432 1067 4F                      LD       C,A         ; Number of dimensions 
 2433 1068 CD6104                  CALL     CHKSTK      ; Check if enough memor
 2434 106B 23                      INC      HL          ; Point to number of di
 2435 106C 23                      INC      HL
 2436 106D 220A81                  LD       (CUROPR),HL ; Save address of point
 2437 1070 71                      LD       (HL),C      ; Set number of dimensi
 2438 1071 23                      INC      HL
 2439 1072 3AF180                  LD       A,(LCRFLG)  ; Locate of Create?
 2440 1075 17                      RLA                  ; Carry set = Create
 2441 1076 79                      LD       A,C         ; Get number of dimensi
 2442 1077 010B00       CRARLP:    LD       BC,10+1     ; Default dimension siz
 2443 107A D27F10                  JP       NC,DEFSIZ   ; Locate - Set default 
 2444 107D C1                      POP      BC          ; Get specified dimensi
 2445 107E 03                      INC      BC          ; Include zero element
 2446 107F 71           DEFSIZ:    LD       (HL),C      ; Save LSB of dimension
 2447 1080 23                      INC      HL
 2448 1081 70                      LD       (HL),B      ; Save MSB of dimension
 2449 1082 23                      INC      HL
 2450 1083 F5                      PUSH     AF          ; Save num' of dim'ns a
 2451 1084 E5                      PUSH     HL          ; Save address of dim'n
 2452 1085 CD1718                  CALL     MLDEBC      ; Multiply DE by BC to 
 2453 1088 EB                      EX       DE,HL       ; amount of mem needed 
 2454 1089 E1                      POP      HL          ; Restore address of di
 2455 108A F1                      POP      AF          ; Restore number of dim
 2456 108B 3D                      DEC      A           ; Count them
 2457 108C C27710                  JP       NZ,CRARLP   ; Do next dimension if 
 2458 108F F5                      PUSH     AF          ; Save locate/create fl
 2459 1090 42                      LD       B,D         ; MSB of memory needed
 2460 1091 4B                      LD       C,E         ; LSB of memory needed
 2461 1092 EB                      EX       DE,HL
 2462 1093 19                      ADD      HL,DE       ; Add bytes to array st
 2463 1094 DA7904                  JP       C,OMERR     ; Too big - Error
 2464 1097 CD6A04                  CALL     ENFMEM      ; See if enough memory
 2465 109A 221F81                  LD       (ARREND),HL ; Save new end of array
 2466                   ;
 2467 109D 2B           ZERARY:    DEC      HL          ; Back through array da
 2468 109E 3600                    LD       (HL),0      ; Set array element to 
 2469 10A0 CD4C07                  CALL     CPDEHL      ; All elements zeroed?
 2470 10A3 C29D10                  JP       NZ,ZERARY   ; No - Keep on going
 2471 10A6 03                      INC      BC          ; Number of bytes + 1
 2472 10A7 57                      LD       D,A         ; A=0
 2473 10A8 2A0A81                  LD       HL,(CUROPR) ; Get address of array
 2474 10AB 5E                      LD       E,(HL)      ; Number of dimensions
 2475 10AC EB                      EX       DE,HL       ; To HL
 2476 10AD 29                      ADD      HL,HL       ; Two bytes per dimensi
 2477 10AE 09                      ADD      HL,BC       ; Add number of bytes
 2478 10AF EB                      EX       DE,HL       ; Bytes needed to DE
 2479 10B0 2B                      DEC      HL
 2480 10B1 2B                      DEC      HL
 2481 10B2 73                      LD       (HL),E      ; Save LSB of bytes nee
 2482 10B3 23                      INC      HL
 2483 10B4 72                      LD       (HL),D      ; Save MSB of bytes nee
 2484 10B5 23                      INC      HL
 2485 10B6 F1                      POP      AF          ; Locate / Create?
 2486 10B7 DADE10                  JP       C,ENDDIM    ; A is 0 , End if creat
 2487 10BA 47           FINDEL:    LD       B,A         ; Find array element
 2488 10BB 4F                      LD       C,A
 2489 10BC 7E                      LD       A,(HL)      ; Number of dimensions
 2490 10BD 23                      INC      HL
 2491 10BE 16                      DB       16H         ; Skip "POP HL"
 2492 10BF E1           FNDELP:    POP      HL          ; Address of next dim' 
 2493 10C0 5E                      LD       E,(HL)      ; Get LSB of dim'n size
 2494 10C1 23                      INC      HL
 2495 10C2 56                      LD       D,(HL)      ; Get MSB of dim'n size
 2496 10C3 23                      INC      HL
 2497 10C4 E3                      EX       (SP),HL     ; Save address - Get in
 2498 10C5 F5                      PUSH     AF          ; Save number of dim'ns
 2499 10C6 CD4C07                  CALL     CPDEHL      ; Dimension too large?
 2500 10C9 D25710                  JP       NC,BSERR    ; Yes - ?BS Error
 2501 10CC E5                      PUSH     HL          ; Save index
 2502 10CD CD1718                  CALL     MLDEBC      ; Multiply previous by 
 2503 10D0 D1                      POP      DE          ; Index supplied to DE
 2504 10D1 19                      ADD      HL,DE       ; Add index to pointer
 2505 10D2 F1                      POP      AF          ; Number of dimensions
 2506 10D3 3D                      DEC      A           ; Count them
 2507 10D4 44                      LD       B,H         ; MSB of pointer
 2508 10D5 4D                      LD       C,L         ; LSB of pointer
 2509 10D6 C2BF10                  JP       NZ,FNDELP   ; More - Keep going
 2510 10D9 29                      ADD      HL,HL       ; 4 Bytes per element
 2511 10DA 29                      ADD      HL,HL
 2512 10DB C1                      POP      BC          ; Start of array
 2513 10DC 09                      ADD      HL,BC       ; Point to element
 2514 10DD EB                      EX       DE,HL       ; Address of element to
 2515 10DE 2A1581       ENDDIM:    LD       HL,(NXTOPR) ; Got code string addre
 2516 10E1 C9                      RET
 2517                   ;
 2518 10E2 2A1F81       FRE:       LD       HL,(ARREND) ; Start of free memory
 2519 10E5 EB                      EX       DE,HL       ; To DE
 2520 10E6 210000                  LD       HL,0        ; End of free memory
 2521 10E9 39                      ADD      HL,SP       ; Current stack value
 2522 10EA 3AF280                  LD       A,(TYPE)    ; Dummy argument type
 2523 10ED B7                      OR       A
 2524 10EE CAFE10                  JP       Z,FRENUM    ; Numeric - Free variab
 2525 10F1 CD6513                  CALL     GSTRCU      ; Current string to poo
 2526 10F4 CD6512                  CALL     GARBGE      ; Garbage collection
 2527 10F7 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2528 10FA EB                      EX       DE,HL       ; To DE
 2529 10FB 2A0881                  LD       HL,(STRBOT) ; Bottom of string spac
 2530 10FE 7D           FRENUM:    LD       A,L         ; Get LSB of end
 2531 10FF 93                      SUB      E           ; Subtract LSB of begin
 2532 1100 4F                      LD       C,A         ; Save difference if C
 2533 1101 7C                      LD       A,H         ; Get MSB of end
 2534 1102 9A                      SBC      A,D         ; Subtract MSB of begin
 2535 1103 41           ACPASS:    LD       B,C         ; Return integer AC
 2536 1104 50           ABPASS:    LD       D,B         ; Return integer AB
 2537 1105 1E00                    LD       E,0
 2538 1107 21F280                  LD       HL,TYPE     ; Point to type
 2539 110A 73                      LD       (HL),E      ; Set type to numeric
 2540 110B 0690                    LD       B,80H+16    ; 16 bit integer
 2541 110D C34217                  JP       RETINT      ; Return the integr
 2542                   ;
 2543 1110 3AF080       POS:       LD       A,(CURPOS)  ; Get cursor position
 2544 1113 47           PASSA:     LD       B,A         ; Put A into AB
 2545 1114 AF                      XOR      A           ; Zero A
 2546 1115 C30411                  JP       ABPASS      ; Return integer AB
 2547                   ;
 2548 1118 CD9B11       DEF:       CALL     CHEKFN      ; Get "FN" and name
 2549 111B CD8D11                  CALL     IDTEST      ; Test for illegal dire
 2550 111E 01730A                  LD       BC,DATA     ; To get next statement
 2551 1121 C5                      PUSH     BC          ; Save address for RETu
 2552 1122 D5                      PUSH     DE          ; Save address of funct
 2553 1123 CD5207                  CALL     CHKSYN      ; Make sure "(" follows
 2554 1126 28                      DB       "("
 2555 1127 CD3F0F                  CALL     GETVAR      ; Get argument variable
 2556 112A E5                      PUSH     HL          ; Save code string addr
 2557 112B EB                      EX       DE,HL       ; Argument address to H
 2558 112C 2B                      DEC      HL
 2559 112D 56                      LD       D,(HL)      ; Get first byte of arg
 2560 112E 2B                      DEC      HL
 2561 112F 5E                      LD       E,(HL)      ; Get second byte of ar
 2562 1130 E1                      POP      HL          ; Restore code string a
 2563 1131 CD4C0D                  CALL     TSTNUM      ; Make sure numeric arg
 2564 1134 CD5207                  CALL     CHKSYN      ; Make sure ")" follows
 2565 1137 29                      DB       ")"
 2566 1138 CD5207                  CALL     CHKSYN      ; Make sure "=" follows
 2567 113B B4                      DB       ZEQUAL      ; "=" token
 2568 113C 44                      LD       B,H         ; Code string address t
 2569 113D 4D                      LD       C,L
 2570 113E E3                      EX       (SP),HL     ; Save code str , Get F
 2571 113F 71                      LD       (HL),C      ; Save LSB of FN code s
 2572 1140 23                      INC      HL
 2573 1141 70                      LD       (HL),B      ; Save MSB of FN code s
 2574 1142 C3DA11                  JP       SVSTAD      ; Save address and do f
 2575                   ;
 2576 1145 CD9B11       DOFN:      CALL     CHEKFN      ; Make sure FN follows
 2577 1148 D5                      PUSH     DE          ; Save function pointer
 2578 1149 CD200E                  CALL     EVLPAR      ; Evaluate expression i
 2579 114C CD4C0D                  CALL     TSTNUM      ; Make sure numeric res
 2580 114F E3                      EX       (SP),HL     ; Save code str , Get F
 2581 1150 5E                      LD       E,(HL)      ; Get LSB of FN code st
 2582 1151 23                      INC      HL
 2583 1152 56                      LD       D,(HL)      ; Get MSB of FN code st
 2584 1153 23                      INC      HL
 2585 1154 7A                      LD       A,D         ; And function DEFined?
 2586 1155 B3                      OR       E
 2587 1156 CA9004                  JP       Z,UFERR     ; No - ?UF Error
 2588 1159 7E                      LD       A,(HL)      ; Get LSB of argument a
 2589 115A 23                      INC      HL
 2590 115B 66                      LD       H,(HL)      ; Get MSB of argument a
 2591 115C 6F                      LD       L,A         ; HL = Arg variable add
 2592 115D E5                      PUSH     HL          ; Save it
 2593 115E 2A2381                  LD       HL,(FNRGNM) ; Get old argument name
 2594 1161 E3                      EX       (SP),HL     ;        ; Save old , G
 2595 1162 222381                  LD       (FNRGNM),HL ; Set new argument name
 2596 1165 2A2781                  LD       HL,(FNARG+2) ; Get LSB,NLSB of old 
 2597 1168 E5                      PUSH     HL          ; Save it
 2598 1169 2A2581                  LD       HL,(FNARG)  ; Get MSB,EXP of old ar
 2599 116C E5                      PUSH     HL          ; Save it
 2600 116D 212581                  LD       HL,FNARG    ; HL = Value of argumen
 2601 1170 D5                      PUSH     DE          ; Save FN code string a
 2602 1171 CD8317                  CALL     FPTHL       ; Move FPREG to argumen
 2603 1174 E1                      POP      HL          ; Get FN code string ad
 2604 1175 CD490D                  CALL     GETNUM      ; Get value from functi
 2605 1178 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2606 1179 CDDC08                  CALL     GETCHR      ; Get next character
 2607 117C C28404                  JP       NZ,SNERR    ; Bad character in FN -
 2608 117F E1                      POP      HL          ; Get MSB,EXP of old ar
 2609 1180 222581                  LD       (FNARG),HL  ; Restore it
 2610 1183 E1                      POP      HL          ; Get LSB,NLSB of old a
 2611 1184 222781                  LD       (FNARG+2),HL ; Restore it
 2612 1187 E1                      POP      HL          ; Get name of old arg
 2613 1188 222381                  LD       (FNRGNM),HL ; Restore it
 2614 118B E1                      POP      HL          ; Restore code string a
 2615 118C C9                      RET
 2616                   ;
 2617 118D E5           IDTEST:    PUSH     HL          ; Save code string addr
 2618 118E 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 2619 1191 23                      INC      HL          ; -1 means direct state
 2620 1192 7C                      LD       A,H
 2621 1193 B5                      OR       L
 2622 1194 E1                      POP      HL          ; Restore code string a
 2623 1195 C0                      RET      NZ          ; Return if in program
 2624 1196 1E16                    LD       E,ID        ; ?ID Error
 2625 1198 C39804                  JP       ERROR
 2626                   ;
 2627 119B CD5207       CHEKFN:    CALL     CHKSYN      ; Make sure FN follows
 2628 119E A7                      DB       ZFN         ; "FN" token
 2629 119F 3E80                    LD       A,80H
 2630 11A1 321081                  LD       (FORFLG),A  ; Flag FN name to find
 2631 11A4 B6                      OR       (HL)        ; FN name has bit 7 set
 2632 11A5 47                      LD       B,A         ; in first byte of name
 2633 11A6 CD440F                  CALL     GTFNAM      ; Get FN name
 2634 11A9 C34C0D                  JP       TSTNUM      ; Make sure numeric fun
 2635                   ;
 2636 11AC CD4C0D       STR:       CALL     TSTNUM      ; Make sure it's a numb
 2637 11AF CDD018                  CALL     NUMASC      ; Turn number into text
 2638 11B2 CDE011       STR1:      CALL     CRTST       ; Create string entry f
 2639 11B5 CD6513                  CALL     GSTRCU      ; Current string to poo
 2640 11B8 01C013                  LD       BC,TOPOOL   ; Save in string pool
 2641 11BB C5                      PUSH     BC          ; Save address on stack
 2642                   ;
 2643 11BC 7E           SAVSTR:    LD       A,(HL)      ; Get string length
 2644 11BD 23                      INC      HL
 2645 11BE 23                      INC      HL
 2646 11BF E5                      PUSH     HL          ; Save pointer to strin
 2647 11C0 CD3B12                  CALL     TESTR       ; See if enough string 
 2648 11C3 E1                      POP      HL          ; Restore pointer to st
 2649 11C4 4E                      LD       C,(HL)      ; Get LSB of address
 2650 11C5 23                      INC      HL
 2651 11C6 46                      LD       B,(HL)      ; Get MSB of address
 2652 11C7 CDD411                  CALL     CRTMST      ; Create string entry
 2653 11CA E5                      PUSH     HL          ; Save pointer to MSB o
 2654 11CB 6F                      LD       L,A         ; Length of string
 2655 11CC CD5813                  CALL     TOSTRA      ; Move to string area
 2656 11CF D1                      POP      DE          ; Restore pointer to MS
 2657 11D0 C9                      RET
 2658                   ;
 2659 11D1 CD3B12       MKTMST:    CALL     TESTR       ; See if enough string 
 2660 11D4 210481       CRTMST:    LD       HL,TMPSTR   ; Temporary string
 2661 11D7 E5                      PUSH     HL          ; Save it
 2662 11D8 77                      LD       (HL),A      ; Save length of string
 2663 11D9 23                      INC      HL
 2664 11DA 23           SVSTAD:    INC      HL
 2665 11DB 73                      LD       (HL),E      ; Save LSB of address
 2666 11DC 23                      INC      HL
 2667 11DD 72                      LD       (HL),D      ; Save MSB of address
 2668 11DE E1                      POP      HL          ; Restore pointer
 2669 11DF C9                      RET
 2670                   ;
 2671 11E0 2B           CRTST:     DEC      HL          ; DEC - INCed after
 2672 11E1 0622         QTSTR:     LD       B,'"'       ; Terminating quote
 2673 11E3 50                      LD       D,B         ; Quote to D
 2674 11E4 E5           DTSTR:     PUSH     HL          ; Save start
 2675 11E5 0EFF                    LD       C,-1        ; Set counter to -1
 2676 11E7 23           QTSTLP:    INC      HL          ; Move on
 2677 11E8 7E                      LD       A,(HL)      ; Get byte
 2678 11E9 0C                      INC      C           ; Count bytes
 2679 11EA B7                      OR       A           ; End of line?
 2680 11EB CAF611                  JP       Z,CRTSTE    ; Yes - Create string e
 2681 11EE BA                      CP       D           ; Terminator D found?
 2682 11EF CAF611                  JP       Z,CRTSTE    ; Yes - Create string e
 2683 11F2 B8                      CP       B           ; Terminator B found?
 2684 11F3 C2E711                  JP       NZ,QTSTLP   ; No - Keep looking
 2685 11F6 FE22         CRTSTE:    CP       '"'         ; End with '"'?
 2686 11F8 CCDC08                  CALL     Z,GETCHR    ; Yes - Get next charac
 2687 11FB E3                      EX       (SP),HL     ; Starting quote
 2688 11FC 23                      INC      HL          ; First byte of string
 2689 11FD EB                      EX       DE,HL       ; To DE
 2690 11FE 79                      LD       A,C         ; Get length
 2691 11FF CDD411                  CALL     CRTMST      ; Create string entry
 2692 1202 110481       TSTOPL:    LD       DE,TMPSTR   ; Temporary string
 2693 1205 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2694 1208 222981                  LD       (FPREG),HL  ; Save address of strin
 2695 120B 3E01                    LD       A,1
 2696 120D 32F280                  LD       (TYPE),A    ; Set type to string
 2697 1210 CD8617                  CALL     DETHL4      ; Move string to pool
 2698 1213 CD4C07                  CALL     CPDEHL      ; Out of string pool?
 2699 1216 22F680                  LD       (TMSTPT),HL ; Save new pointer
 2700 1219 E1                      POP      HL          ; Restore code string a
 2701 121A 7E                      LD       A,(HL)      ; Get next code byte
 2702 121B C0                      RET      NZ          ; Return if pool OK
 2703 121C 1E1E                    LD       E,ST        ; ?ST Error
 2704 121E C39804                  JP       ERROR       ; String pool overflow
 2705                   ;
 2706 1221 23           PRNUMS:    INC      HL          ; Skip leading space
 2707 1222 CDE011       PRS:       CALL     CRTST       ; Create string entry f
 2708 1225 CD6513       PRS1:      CALL     GSTRCU      ; Current string to poo
 2709 1228 CD7A17                  CALL     LOADFP      ; Move string block to 
 2710 122B 1C                      INC      E           ; Length + 1
 2711 122C 1D           PRSLP:     DEC      E           ; Count characters
 2712 122D C8                      RET      Z           ; End of string
 2713 122E 0A                      LD       A,(BC)      ; Get byte to output
 2714 122F CD5D07                  CALL     OUTC        ; Output character in A
 2715 1232 FE0D                    CP       CR          ; Return?
 2716 1234 CC8E0B                  CALL     Z,DONULL    ; Yes - Do nulls
 2717 1237 03                      INC      BC          ; Next byte in string
 2718 1238 C32C12                  JP       PRSLP       ; More characters to ou
 2719                   ;
 2720 123B B7           TESTR:     OR       A           ; Test if enough room
 2721 123C 0E                      DB       0EH         ; No garbage collection
 2722 123D F1           GRBDON:    POP      AF          ; Garbage collection do
 2723 123E F5                      PUSH     AF          ; Save status
 2724 123F 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2725 1242 EB                      EX       DE,HL       ; To DE
 2726 1243 2A0881                  LD       HL,(STRBOT) ; Bottom of string area
 2727 1246 2F                      CPL                  ; Negate length (Top do
 2728 1247 4F                      LD       C,A         ; -Length to BC
 2729 1248 06FF                    LD       B,-1        ; BC = -ve length of st
 2730 124A 09                      ADD      HL,BC       ; Add to bottom of spac
 2731 124B 23                      INC      HL          ; Plus one for 2's comp
 2732 124C CD4C07                  CALL     CPDEHL      ; Below string RAM area
 2733 124F DA5912                  JP       C,TESTOS    ; Tidy up if not done e
 2734 1252 220881                  LD       (STRBOT),HL ; Save new bottom of ar
 2735 1255 23                      INC      HL          ; Point to first byte o
 2736 1256 EB                      EX       DE,HL       ; Address to DE
 2737 1257 F1           POPAF:     POP      AF          ; Throw away status pus
 2738 1258 C9                      RET
 2739                   ;
 2740 1259 F1           TESTOS:    POP      AF          ; Garbage collect been 
 2741 125A 1E1A                    LD       E,OS        ; ?OS Error
 2742 125C CA9804                  JP       Z,ERROR     ; Yes - Not enough stri
 2743 125F BF                      CP       A           ; Flag garbage collect 
 2744 1260 F5                      PUSH     AF          ; Save status
 2745 1261 013D12                  LD       BC,GRBDON   ; Garbage collection do
 2746 1264 C5                      PUSH     BC          ; Save for RETurn
 2747 1265 2AF480       GARBGE:    LD       HL,(LSTRAM) ; Get end of RAM pointe
 2748 1268 220881       GARBLP:    LD       (STRBOT),HL ; Reset string pointer
 2749 126B 210000                  LD       HL,0
 2750 126E E5                      PUSH     HL          ; Flag no string found
 2751 126F 2A9F80                  LD       HL,(STRSPC) ; Get bottom of string 
 2752 1272 E5                      PUSH     HL          ; Save bottom of string
 2753 1273 21F880                  LD       HL,TMSTPL   ; Temporary string pool
 2754 1276 EB           GRBLP:     EX       DE,HL
 2755 1277 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2756 127A EB                      EX       DE,HL
 2757 127B CD4C07                  CALL     CPDEHL      ; Temporary string pool
 2758 127E 017612                  LD       BC,GRBLP    ; Loop until string poo
 2759 1281 C2CA12                  JP       NZ,STPOOL   ; No - See if in string
 2760 1284 2A1B81                  LD       HL,(PROGND) ; Start of simple varia
 2761 1287 EB           SMPVAR:    EX       DE,HL
 2762 1288 2A1D81                  LD       HL,(VAREND) ; End of simple variabl
 2763 128B EB                      EX       DE,HL
 2764 128C CD4C07                  CALL     CPDEHL      ; All simple strings do
 2765 128F CA9D12                  JP       Z,ARRLP     ; Yes - Do string array
 2766 1292 7E                      LD       A,(HL)      ; Get type of variable
 2767 1293 23                      INC      HL
 2768 1294 23                      INC      HL
 2769 1295 B7                      OR       A           ; "S" flag set if strin
 2770 1296 CDCD12                  CALL     STRADD      ; See if string in stri
 2771 1299 C38712                  JP       SMPVAR      ; Loop until simple one
 2772                   ;
 2773 129C C1           GNXARY:    POP      BC          ; Scrap address of this
 2774 129D EB           ARRLP:     EX       DE,HL
 2775 129E 2A1F81                  LD       HL,(ARREND) ; End of string arrays
 2776 12A1 EB                      EX       DE,HL
 2777 12A2 CD4C07                  CALL     CPDEHL      ; All string arrays don
 2778 12A5 CAF312                  JP       Z,SCNEND    ; Yes - Move string if 
 2779 12A8 CD7A17                  CALL     LOADFP      ; Get array name to BCD
 2780 12AB 7B                      LD       A,E         ; Get type of array
 2781 12AC E5                      PUSH     HL          ; Save address of num o
 2782 12AD 09                      ADD      HL,BC       ; Start of next array
 2783 12AE B7                      OR       A           ; Test type of array
 2784 12AF F29C12                  JP       P,GNXARY    ; Numeric array - Ignor
 2785 12B2 220A81                  LD       (CUROPR),HL ; Save address of next 
 2786 12B5 E1                      POP      HL          ; Get address of num of
 2787 12B6 4E                      LD       C,(HL)      ; BC = Number of dimens
 2788 12B7 0600                    LD       B,0
 2789 12B9 09                      ADD      HL,BC       ; Two bytes per dimensi
 2790 12BA 09                      ADD      HL,BC
 2791 12BB 23                      INC      HL          ; Plus one for number o
 2792 12BC EB           GRBARY:    EX       DE,HL
 2793 12BD 2A0A81                  LD       HL,(CUROPR) ; Get address of next a
 2794 12C0 EB                      EX       DE,HL
 2795 12C1 CD4C07                  CALL     CPDEHL      ; Is this array finishe
 2796 12C4 CA9D12                  JP       Z,ARRLP     ; Yes - Get next one
 2797 12C7 01BC12                  LD       BC,GRBARY   ; Loop until array all 
 2798 12CA C5           STPOOL:    PUSH     BC          ; Save return address
 2799 12CB F680                    OR       80H         ; Flag string type
 2800 12CD 7E           STRADD:    LD       A,(HL)      ; Get string length
 2801 12CE 23                      INC      HL
 2802 12CF 23                      INC      HL
 2803 12D0 5E                      LD       E,(HL)      ; Get LSB of string add
 2804 12D1 23                      INC      HL
 2805 12D2 56                      LD       D,(HL)      ; Get MSB of string add
 2806 12D3 23                      INC      HL
 2807 12D4 F0                      RET      P           ; Not a string - Return
 2808 12D5 B7                      OR       A           ; Set flags on string l
 2809 12D6 C8                      RET      Z           ; Null string - Return
 2810 12D7 44                      LD       B,H         ; Save variable pointer
 2811 12D8 4D                      LD       C,L
 2812 12D9 2A0881                  LD       HL,(STRBOT) ; Bottom of new area
 2813 12DC CD4C07                  CALL     CPDEHL      ; String been done?
 2814 12DF 60                      LD       H,B         ; Restore variable poin
 2815 12E0 69                      LD       L,C
 2816 12E1 D8                      RET      C           ; String done - Ignore
 2817 12E2 E1                      POP      HL          ; Return address
 2818 12E3 E3                      EX       (SP),HL     ; Lowest available stri
 2819 12E4 CD4C07                  CALL     CPDEHL      ; String within string 
 2820 12E7 E3                      EX       (SP),HL     ; Lowest available stri
 2821 12E8 E5                      PUSH     HL          ; Re-save return addres
 2822 12E9 60                      LD       H,B         ; Restore variable poin
 2823 12EA 69                      LD       L,C
 2824 12EB D0                      RET      NC          ; Outside string area -
 2825 12EC C1                      POP      BC          ; Get return , Throw 2 
 2826 12ED F1                      POP      AF          ;
 2827 12EE F1                      POP      AF          ;
 2828 12EF E5                      PUSH     HL          ; Save variable pointer
 2829 12F0 D5                      PUSH     DE          ; Save address of curre
 2830 12F1 C5                      PUSH     BC          ; Put back return addre
 2831 12F2 C9                      RET                  ; Go to it
 2832                   ;
 2833 12F3 D1           SCNEND:    POP      DE          ; Addresses of strings
 2834 12F4 E1                      POP      HL          ;
 2835 12F5 7D                      LD       A,L         ; HL = 0 if no more to 
 2836 12F6 B4                      OR       H
 2837 12F7 C8                      RET      Z           ; No more to do - Retur
 2838 12F8 2B                      DEC      HL
 2839 12F9 46                      LD       B,(HL)      ; MSB of address of str
 2840 12FA 2B                      DEC      HL
 2841 12FB 4E                      LD       C,(HL)      ; LSB of address of str
 2842 12FC E5                      PUSH     HL          ; Save variable address
 2843 12FD 2B                      DEC      HL
 2844 12FE 2B                      DEC      HL
 2845 12FF 6E                      LD       L,(HL)      ; HL = Length of string
 2846 1300 2600                    LD       H,0
 2847 1302 09                      ADD      HL,BC       ; Address of end of str
 2848 1303 50                      LD       D,B         ; String address to DE
 2849 1304 59                      LD       E,C
 2850 1305 2B                      DEC      HL          ; Last byte in string
 2851 1306 44                      LD       B,H         ; Address to BC
 2852 1307 4D                      LD       C,L
 2853 1308 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2854 130B CD5304                  CALL     MOVSTR      ; Move string to new ad
 2855 130E E1                      POP      HL          ; Restore variable addr
 2856 130F 71                      LD       (HL),C      ; Save new LSB of addre
 2857 1310 23                      INC      HL
 2858 1311 70                      LD       (HL),B      ; Save new MSB of addre
 2859 1312 69                      LD       L,C         ; Next string area+1 to
 2860 1313 60                      LD       H,B
 2861 1314 2B                      DEC      HL          ; Next string area addr
 2862 1315 C36812                  JP       GARBLP      ; Look for more strings
 2863                   ;
 2864 1318 C5           CONCAT:    PUSH     BC          ; Save prec' opr & code
 2865 1319 E5                      PUSH     HL          ;
 2866 131A 2A2981                  LD       HL,(FPREG)  ; Get first string
 2867 131D E3                      EX       (SP),HL     ; Save first string
 2868 131E CDD20D                  CALL     OPRND       ; Get second string
 2869 1321 E3                      EX       (SP),HL     ; Restore first string
 2870 1322 CD4D0D                  CALL     TSTSTR      ; Make sure it's a stri
 2871 1325 7E                      LD       A,(HL)      ; Get length of second 
 2872 1326 E5                      PUSH     HL          ; Save first string
 2873 1327 2A2981                  LD       HL,(FPREG)  ; Get second string
 2874 132A E5                      PUSH     HL          ; Save second string
 2875 132B 86                      ADD      A,(HL)      ; Add length of second 
 2876 132C 1E1C                    LD       E,LS        ; ?LS Error
 2877 132E DA9804                  JP       C,ERROR     ; String too long - Err
 2878 1331 CDD111                  CALL     MKTMST      ; Make temporary string
 2879 1334 D1                      POP      DE          ; Get second string to 
 2880 1335 CD6913                  CALL     GSTRDE      ; Move to string pool i
 2881 1338 E3                      EX       (SP),HL     ; Get first string
 2882 1339 CD6813                  CALL     GSTRHL      ; Move to string pool i
 2883 133C E5                      PUSH     HL          ; Save first string
 2884 133D 2A0681                  LD       HL,(TMPSTR+2) ; Temporary string ad
 2885 1340 EB                      EX       DE,HL       ; To DE
 2886 1341 CD4F13                  CALL     SSTSA       ; First string to strin
 2887 1344 CD4F13                  CALL     SSTSA       ; Second string to stri
 2888 1347 21670D                  LD       HL,EVAL2    ; Return to evaluation 
 2889 134A E3                      EX       (SP),HL     ; Save return,get code 
 2890 134B E5                      PUSH     HL          ; Save code string addr
 2891 134C C30212                  JP       TSTOPL      ; To temporary string t
 2892                   ;
 2893 134F E1           SSTSA:     POP      HL          ; Return address
 2894 1350 E3                      EX       (SP),HL     ; Get string block,save
 2895 1351 7E                      LD       A,(HL)      ; Get length of string
 2896 1352 23                      INC      HL
 2897 1353 23                      INC      HL
 2898 1354 4E                      LD       C,(HL)      ; Get LSB of string add
 2899 1355 23                      INC      HL
 2900 1356 46                      LD       B,(HL)      ; Get MSB of string add
 2901 1357 6F                      LD       L,A         ; Length to L
 2902 1358 2C           TOSTRA:    INC      L           ; INC - DECed after
 2903 1359 2D           TSALP:     DEC      L           ; Count bytes moved
 2904 135A C8                      RET      Z           ; End of string - Retur
 2905 135B 0A                      LD       A,(BC)      ; Get source
 2906 135C 12                      LD       (DE),A      ; Save destination
 2907 135D 03                      INC      BC          ; Next source
 2908 135E 13                      INC      DE          ; Next destination
 2909 135F C35913                  JP       TSALP       ; Loop until string mov
 2910                   ;
 2911 1362 CD4D0D       GETSTR:    CALL     TSTSTR      ; Make sure it's a stri
 2912 1365 2A2981       GSTRCU:    LD       HL,(FPREG)  ; Get current string
 2913 1368 EB           GSTRHL:    EX       DE,HL       ; Save DE
 2914 1369 CD8313       GSTRDE:    CALL     BAKTMP      ; Was it last tmp-str?
 2915 136C EB                      EX       DE,HL       ; Restore DE
 2916 136D C0                      RET      NZ          ; No - Return
 2917 136E D5                      PUSH     DE          ; Save string
 2918 136F 50                      LD       D,B         ; String block address 
 2919 1370 59                      LD       E,C
 2920 1371 1B                      DEC      DE          ; Point to length
 2921 1372 4E                      LD       C,(HL)      ; Get string length
 2922 1373 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2923 1376 CD4C07                  CALL     CPDEHL      ; Last one in string ar
 2924 1379 C28113                  JP       NZ,POPHL    ; No - Return
 2925 137C 47                      LD       B,A         ; Clear B (A=0)
 2926 137D 09                      ADD      HL,BC       ; Remove string from st
 2927 137E 220881                  LD       (STRBOT),HL ; Save new bottom of st
 2928 1381 E1           POPHL:     POP      HL          ; Restore string
 2929 1382 C9                      RET
 2930                   ;
 2931 1383 2AF680       BAKTMP:    LD       HL,(TMSTPT) ; Get temporary string 
 2932 1386 2B                      DEC      HL          ; Back
 2933 1387 46                      LD       B,(HL)      ; Get MSB of address
 2934 1388 2B                      DEC      HL          ; Back
 2935 1389 4E                      LD       C,(HL)      ; Get LSB of address
 2936 138A 2B                      DEC      HL          ; Back
 2937 138B 2B                      DEC      HL          ; Back
 2938 138C CD4C07                  CALL     CPDEHL      ; String last in string
 2939 138F C0                      RET      NZ          ; Yes - Leave it
 2940 1390 22F680                  LD       (TMSTPT),HL ; Save new string pool 
 2941 1393 C9                      RET
 2942                   ;
 2943 1394 011311       LEN:       LD       BC,PASSA    ; To return integer A
 2944 1397 C5                      PUSH     BC          ; Save address
 2945 1398 CD6213       GETLEN:    CALL     GETSTR      ; Get string and its le
 2946 139B AF                      XOR      A
 2947 139C 57                      LD       D,A         ; Clear D
 2948 139D 32F280                  LD       (TYPE),A    ; Set type to numeric
 2949 13A0 7E                      LD       A,(HL)      ; Get length of string
 2950 13A1 B7                      OR       A           ; Set status flags
 2951 13A2 C9                      RET
 2952                   ;
 2953 13A3 011311       ASC:       LD       BC,PASSA    ; To return integer A
 2954 13A6 C5                      PUSH     BC          ; Save address
 2955 13A7 CD9813       GTFLNM:    CALL     GETLEN      ; Get length of string
 2956 13AA CAA309                  JP       Z,FCERR     ; Null string - Error
 2957 13AD 23                      INC      HL
 2958 13AE 23                      INC      HL
 2959 13AF 5E                      LD       E,(HL)      ; Get LSB of address
 2960 13B0 23                      INC      HL
 2961 13B1 56                      LD       D,(HL)      ; Get MSB of address
 2962 13B2 1A                      LD       A,(DE)      ; Get first byte of str
 2963 13B3 C9                      RET
 2964                   ;
 2965 13B4 3E01         CHR:       LD       A,1         ; One character string
 2966 13B6 CDD111                  CALL     MKTMST      ; Make a temporary stri
 2967 13B9 CDAD14                  CALL     MAKINT      ; Make it integer A
 2968 13BC 2A0681                  LD       HL,(TMPSTR+2) ; Get address of stri
 2969 13BF 73                      LD       (HL),E      ; Save character
 2970 13C0 C1           TOPOOL:    POP      BC          ; Clean up stack
 2971 13C1 C30212                  JP       TSTOPL      ; Temporary string to p
 2972                   ;
 2973 13C4 CD5D14       LEFT:      CALL     LFRGNM      ; Get number and ending
 2974 13C7 AF                      XOR      A           ; Start at first byte i
 2975 13C8 E3           RIGHT1:    EX       (SP),HL     ; Save code string,Get 
 2976 13C9 4F                      LD       C,A         ; Starting position in 
 2977 13CA E5           MID1:      PUSH     HL          ; Save string block add
 2978 13CB 7E                      LD       A,(HL)      ; Get length of string
 2979 13CC B8                      CP       B           ; Compare with number g
 2980 13CD DAD213                  JP       C,ALLFOL    ; All following bytes r
 2981 13D0 78                      LD       A,B         ; Get new length
 2982 13D1 11                      DB       11H         ; Skip "LD C,0"
 2983 13D2 0E00         ALLFOL:    LD       C,0         ; First byte of string
 2984 13D4 C5                      PUSH     BC          ; Save position in stri
 2985 13D5 CD3B12                  CALL     TESTR       ; See if enough string 
 2986 13D8 C1                      POP      BC          ; Get position in strin
 2987 13D9 E1                      POP      HL          ; Restore string block 
 2988 13DA E5                      PUSH     HL          ; And re-save it
 2989 13DB 23                      INC      HL
 2990 13DC 23                      INC      HL
 2991 13DD 46                      LD       B,(HL)      ; Get LSB of address
 2992 13DE 23                      INC      HL
 2993 13DF 66                      LD       H,(HL)      ; Get MSB of address
 2994 13E0 68                      LD       L,B         ; HL = address of strin
 2995 13E1 0600                    LD       B,0         ; BC = starting address
 2996 13E3 09                      ADD      HL,BC       ; Point to that byte
 2997 13E4 44                      LD       B,H         ; BC = source string
 2998 13E5 4D                      LD       C,L
 2999 13E6 CDD411                  CALL     CRTMST      ; Create a string entry
 3000 13E9 6F                      LD       L,A         ; Length of new string
 3001 13EA CD5813                  CALL     TOSTRA      ; Move string to string
 3002 13ED D1                      POP      DE          ; Clear stack
 3003 13EE CD6913                  CALL     GSTRDE      ; Move to string pool i
 3004 13F1 C30212                  JP       TSTOPL      ; Temporary string to p
 3005                   ;
 3006 13F4 CD5D14       RIGHT:     CALL     LFRGNM      ; Get number and ending
 3007 13F7 D1                      POP      DE          ; Get string length
 3008 13F8 D5                      PUSH     DE          ; And re-save
 3009 13F9 1A                      LD       A,(DE)      ; Get length
 3010 13FA 90                      SUB      B           ; Move back N bytes
 3011 13FB C3C813                  JP       RIGHT1      ; Go and get sub-string
 3012                   ;
 3013 13FE EB           MID:       EX       DE,HL       ; Get code string addre
 3014 13FF 7E                      LD       A,(HL)      ; Get next byte ',' or 
 3015 1400 CD6214                  CALL     MIDNUM      ; Get number supplied
 3016 1403 04                      INC      B           ; Is it character zero?
 3017 1404 05                      DEC      B
 3018 1405 CAA309                  JP       Z,FCERR     ; Yes - Error
 3019 1408 C5                      PUSH     BC          ; Save starting positio
 3020 1409 1EFF                    LD       E,255       ; All of string
 3021 140B FE29                    CP       ')'         ; Any length given?
 3022 140D CA1714                  JP       Z,RSTSTR    ; No - Rest of string
 3023 1410 CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 3024 1413 2C                      DB       ','
 3025 1414 CDAA14                  CALL     GETINT      ; Get integer 0-255
 3026 1417 CD5207       RSTSTR:    CALL     CHKSYN      ; Make sure ")" follows
 3027 141A 29                      DB       ")"
 3028 141B F1                      POP      AF          ; Restore starting posi
 3029 141C E3                      EX       (SP),HL     ; Get string,8ave code 
 3030 141D 01CA13                  LD       BC,MID1     ; Continuation of MID$ 
 3031 1420 C5                      PUSH     BC          ; Save for return
 3032 1421 3D                      DEC      A           ; Starting position-1
 3033 1422 BE                      CP       (HL)        ; Compare with length
 3034 1423 0600                    LD       B,0         ; Zero bytes length
 3035 1425 D0                      RET      NC          ; Null string if start 
 3036 1426 4F                      LD       C,A         ; Save starting positio
 3037 1427 7E                      LD       A,(HL)      ; Get length of string
 3038 1428 91                      SUB      C           ; Subtract start
 3039 1429 BB                      CP       E           ; Enough string for it?
 3040 142A 47                      LD       B,A         ; Save maximum length a
 3041 142B D8                      RET      C           ; Truncate string if ne
 3042 142C 43                      LD       B,E         ; Set specified length
 3043 142D C9                      RET                  ; Go and create string
 3044                   ;
 3045 142E CD9813       VAL:       CALL     GETLEN      ; Get length of string
 3046 1431 CA4B15                  JP       Z,RESZER    ; Result zero
 3047 1434 5F                      LD       E,A         ; Save length
 3048 1435 23                      INC      HL
 3049 1436 23                      INC      HL
 3050 1437 7E                      LD       A,(HL)      ; Get LSB of address
 3051 1438 23                      INC      HL
 3052 1439 66                      LD       H,(HL)      ; Get MSB of address
 3053 143A 6F                      LD       L,A         ; HL = String address
 3054 143B E5                      PUSH     HL          ; Save string address
 3055 143C 19                      ADD      HL,DE
 3056 143D 46                      LD       B,(HL)      ; Get end of string+1 b
 3057 143E 72                      LD       (HL),D      ; Zero it to terminate
 3058 143F E3                      EX       (SP),HL     ; Save string end,get s
 3059 1440 C5                      PUSH     BC          ; Save end+1 byte
 3060 1441 7E                      LD       A,(HL)      ; Get starting byte
 3061 1442 FE24                    CP       '$'         ; Hex number indicated?
 3062 1444 C24C14                  JP       NZ,VAL1
 3063 1447 CD761C                  CALL     HEXTFP      ; Convert Hex to FPREG
 3064 144A 180D                    JR       VAL3
 3065 144C FE25         VAL1:      CP       '%'         ; Binary number indicat
 3066 144E C25614                  JP       NZ,VAL2
 3067 1451 CDE61C                  CALL     BINTFP      ; Convert Bin to FPREG
 3068 1454 1803                    JR       VAL3
 3069 1456 CD3218       VAL2:      CALL     ASCTFP      ; Convert ASCII string 
 3070 1459 C1           VAL3:      POP      BC          ; Restore end+1 byte
 3071 145A E1                      POP      HL          ; Restore end+1 address
 3072 145B 70                      LD       (HL),B      ; Put back original byt
 3073 145C C9                      RET
 3074                   ;
 3075 145D EB           LFRGNM:    EX       DE,HL       ; Code string address t
 3076 145E CD5207                  CALL     CHKSYN      ; Make sure ")" follows
 3077 1461 29                      DB       ")"
 3078 1462 C1           MIDNUM:    POP      BC          ; Get return address
 3079 1463 D1                      POP      DE          ; Get number supplied
 3080 1464 C5                      PUSH     BC          ; Re-save return addres
 3081 1465 43                      LD       B,E         ; Number to B
 3082 1466 C9                      RET
 3083                   ;
 3084 1467 CDAD14       INP:       CALL     MAKINT      ; Make it integer A
 3085 146A 328480                  LD       (INPORT),A  ; Set input port
 3086 146D CD8380                  CALL     INPSUB      ; Get input from port
 3087 1470 C31311                  JP       PASSA       ; Return integer A
 3088                   ;
 3089 1473 CD9714       POUT:      CALL     SETIO       ; Set up port number
 3090 1476 C34B80                  JP       OUTSUB      ; Output data and retur
 3091                   ;
 3092 1479 CD9714       WAIT:      CALL     SETIO       ; Set up port number
 3093 147C F5                      PUSH     AF          ; Save AND mask
 3094 147D 1E00                    LD       E,0         ; Assume zero if none g
 3095 147F 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3096 1480 CDDC08                  CALL     GETCHR      ; Get next character
 3097 1483 CA8D14                  JP       Z,NOXOR     ; No XOR byte given
 3098 1486 CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 3099 1489 2C                      DB       ','
 3100 148A CDAA14                  CALL     GETINT      ; Get integer 0-255 to 
 3101 148D C1           NOXOR:     POP      BC          ; Restore AND mask
 3102 148E CD8380       WAITLP:    CALL     INPSUB      ; Get input
 3103 1491 AB                      XOR      E           ; Flip selected bits
 3104 1492 A0                      AND      B           ; Result non-zero?
 3105 1493 CA8E14                  JP       Z,WAITLP    ; No = keep waiting
 3106 1496 C9                      RET
 3107                   ;
 3108 1497 CDAA14       SETIO:     CALL     GETINT      ; Get integer 0-255
 3109 149A 328480                  LD       (INPORT),A  ; Set input port
 3110 149D 324C80                  LD       (OTPORT),A  ; Set output port
 3111 14A0 CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 3112 14A3 2C                      DB       ','
 3113 14A4 C3AA14                  JP       GETINT      ; Get integer 0-255 and
 3114                   ;
 3115 14A7 CDDC08       FNDNUM:    CALL     GETCHR      ; Get next character
 3116 14AA CD490D       GETINT:    CALL     GETNUM      ; Get a number from 0 t
 3117 14AD CD8809       MAKINT:    CALL     DEPINT      ; Make sure value 0 - 2
 3118 14B0 7A                      LD       A,D         ; Get MSB of number
 3119 14B1 B7                      OR       A           ; Zero?
 3120 14B2 C2A309                  JP       NZ,FCERR    ; No - Error
 3121 14B5 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3122 14B6 CDDC08                  CALL     GETCHR      ; Get next character
 3123 14B9 7B                      LD       A,E         ; Get number to A
 3124 14BA C9                      RET
 3125                   ;
 3126 14BB CD8E09       PEEK:      CALL     DEINT       ; Get memory address
 3127 14BE 1A                      LD       A,(DE)      ; Get byte in memory
 3128 14BF C31311                  JP       PASSA       ; Return integer A
 3129                   ;
 3130 14C2 CD490D       POKE:      CALL     GETNUM      ; Get memory address
 3131 14C5 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 3132 14C8 D5                      PUSH     DE          ; Save memory address
 3133 14C9 CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 3134 14CC 2C                      DB       ','
 3135 14CD CDAA14                  CALL     GETINT      ; Get integer 0-255
 3136 14D0 D1                      POP      DE          ; Restore memory addres
 3137 14D1 12                      LD       (DE),A      ; Load it into memory
 3138 14D2 C9                      RET
 3139                   ;
 3140 14D3 21A919       ROUND:     LD       HL,HALF     ; Add 0.5 to FPREG
 3141 14D6 CD7A17       ADDPHL:    CALL     LOADFP      ; Load FP at (HL) to BC
 3142 14D9 C3E514                  JP       FPADD       ; Add BCDE to FPREG
 3143                   ;
 3144 14DC CD7A17       SUBPHL:    CALL     LOADFP      ; FPREG = -FPREG + numb
 3145 14DF 21                      DB       21H         ; Skip "POP BC" and "PO
 3146 14E0 C1           PSUB:      POP      BC          ; Get FP number from st
 3147 14E1 D1                      POP      DE
 3148 14E2 CD5417       SUBCDE:    CALL     INVSGN      ; Negate FPREG
 3149 14E5 78           FPADD:     LD       A,B         ; Get FP exponent
 3150 14E6 B7                      OR       A           ; Is number zero?
 3151 14E7 C8                      RET      Z           ; Yes - Nothing to add
 3152 14E8 3A2C81                  LD       A,(FPEXP)   ; Get FPREG exponent
 3153 14EB B7                      OR       A           ; Is this number zero?
 3154 14EC CA6C17                  JP       Z,FPBCDE    ; Yes - Move BCDE to FP
 3155 14EF 90                      SUB      B           ; BCDE number larger?
 3156 14F0 D2FF14                  JP       NC,NOSWAP   ; No - Don't swap them
 3157 14F3 2F                      CPL                  ; Two's complement
 3158 14F4 3C                      INC      A           ;       FP exponent
 3159 14F5 EB                      EX       DE,HL
 3160 14F6 CD5C17                  CALL     STAKFP      ; Put FPREG on stack
 3161 14F9 EB                      EX       DE,HL
 3162 14FA CD6C17                  CALL     FPBCDE      ; Move BCDE to FPREG
 3163 14FD C1                      POP      BC          ; Restore number from s
 3164 14FE D1                      POP      DE
 3165 14FF FE19         NOSWAP:    CP       24+1        ; Second number insigni
 3166 1501 D0                      RET      NC          ; Yes - First number is
 3167 1502 F5                      PUSH     AF          ; Save number of bits t
 3168 1503 CD9117                  CALL     SIGNS       ; Set MSBs & sign of re
 3169 1506 67                      LD       H,A         ; Save sign of result
 3170 1507 F1                      POP      AF          ; Restore scaling facto
 3171 1508 CDAA15                  CALL     SCALE       ; Scale BCDE to same ex
 3172 150B B4                      OR       H           ; Result to be positive
 3173 150C 212981                  LD       HL,FPREG    ; Point to FPREG
 3174 150F F22515                  JP       P,MINCDE    ; No - Subtract FPREG f
 3175 1512 CD8A15                  CALL     PLUCDE      ; Add FPREG to CDE
 3176 1515 D26B15                  JP       NC,RONDUP   ; No overflow - Round i
 3177 1518 23                      INC      HL          ; Point to exponent
 3178 1519 34                      INC      (HL)        ; Increment it
 3179 151A CA9304                  JP       Z,OVERR     ; Number overflowed - E
 3180 151D 2E01                    LD       L,1         ; 1 bit to shift right
 3181 151F CDC015                  CALL     SHRT1       ; Shift result right
 3182 1522 C36B15                  JP       RONDUP      ; Round it up
 3183                   ;
 3184 1525 AF           MINCDE:    XOR      A           ; Clear A and carry
 3185 1526 90                      SUB      B           ; Negate exponent
 3186 1527 47                      LD       B,A         ; Re-save exponent
 3187 1528 7E                      LD       A,(HL)      ; Get LSB of FPREG
 3188 1529 9B                      SBC      A, E        ; Subtract LSB of BCDE
 3189 152A 5F                      LD       E,A         ; Save LSB of BCDE
 3190 152B 23                      INC      HL
 3191 152C 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3192 152D 9A                      SBC      A,D         ; Subtract NMSB of BCDE
 3193 152E 57                      LD       D,A         ; Save NMSB of BCDE
 3194 152F 23                      INC      HL
 3195 1530 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3196 1531 99                      SBC      A,C         ; Subtract MSB of BCDE
 3197 1532 4F                      LD       C,A         ; Save MSB of BCDE
 3198 1533 DC9615       CONPOS:    CALL     C,COMPL     ; Overflow - Make it po
 3199                   ;
 3200 1536 68           BNORM:     LD       L,B         ; L = Exponent
 3201 1537 63                      LD       H,E         ; H = LSB
 3202 1538 AF                      XOR      A
 3203 1539 47           BNRMLP:    LD       B,A         ; Save bit count
 3204 153A 79                      LD       A,C         ; Get MSB
 3205 153B B7                      OR       A           ; Is it zero?
 3206 153C C25815                  JP       NZ,PNORM    ; No - Do it bit at a t
 3207 153F 4A                      LD       C,D         ; MSB = NMSB
 3208 1540 54                      LD       D,H         ; NMSB= LSB
 3209 1541 65                      LD       H,L         ; LSB = VLSB
 3210 1542 6F                      LD       L,A         ; VLSB= 0
 3211 1543 78                      LD       A,B         ; Get exponent
 3212 1544 D608                    SUB      8           ; Count 8 bits
 3213 1546 FEE0                    CP       0E0H        ; -24-8 Was number zero
 3214 1548 C23915                  JP       NZ,BNRMLP   ; No - Keep normalising
 3215 154B AF           RESZER:    XOR      A           ; Result is zero
 3216 154C 322C81       SAVEXP:    LD       (FPEXP),A   ; Save result as zero
 3217 154F C9                      RET
 3218                   ;
 3219 1550 05           NORMAL:    DEC      B           ; Count bits
 3220 1551 29                      ADD      HL,HL       ; Shift HL left
 3221 1552 7A                      LD       A,D         ; Get NMSB
 3222 1553 17                      RLA                  ; Shift left with last 
 3223 1554 57                      LD       D,A         ; Save NMSB
 3224 1555 79                      LD       A,C         ; Get MSB
 3225 1556 8F                      ADC      A,A         ; Shift left with last 
 3226 1557 4F                      LD       C,A         ; Save MSB
 3227 1558 F25015       PNORM:     JP       P,NORMAL    ; Not done - Keep going
 3228 155B 78                      LD       A,B         ; Number of bits shifte
 3229 155C 5C                      LD       E,H         ; Save HL in EB
 3230 155D 45                      LD       B,L
 3231 155E B7                      OR       A           ; Any shifting done?
 3232 155F CA6B15                  JP       Z,RONDUP    ; No - Round it up
 3233 1562 212C81                  LD       HL,FPEXP    ; Point to exponent
 3234 1565 86                      ADD      A,(HL)      ; Add shifted bits
 3235 1566 77                      LD       (HL),A      ; Re-save exponent
 3236 1567 D24B15                  JP       NC,RESZER   ; Underflow - Result is
 3237 156A C8                      RET      Z           ; Result is zero
 3238 156B 78           RONDUP:    LD       A,B         ; Get VLSB of number
 3239 156C 212C81       RONDB:     LD       HL,FPEXP    ; Point to exponent
 3240 156F B7                      OR       A           ; Any rounding?
 3241 1570 FC7D15                  CALL     M,FPROND    ; Yes - Round number up
 3242 1573 46                      LD       B,(HL)      ; B = Exponent
 3243 1574 23                      INC      HL
 3244 1575 7E                      LD       A,(HL)      ; Get sign of result
 3245 1576 E680                    AND      10000000B   ; Only bit 7 needed
 3246 1578 A9                      XOR      C           ; Set correct sign
 3247 1579 4F                      LD       C,A         ; Save correct sign in 
 3248 157A C36C17                  JP       FPBCDE      ; Move BCDE to FPREG
 3249                   ;
 3250 157D 1C           FPROND:    INC      E           ; Round LSB
 3251 157E C0                      RET      NZ          ; Return if ok
 3252 157F 14                      INC      D           ; Round NMSB
 3253 1580 C0                      RET      NZ          ; Return if ok
 3254 1581 0C                      INC      C           ; Round MSB
 3255 1582 C0                      RET      NZ          ; Return if ok
 3256 1583 0E80                    LD       C,80H       ; Set normal value
 3257 1585 34                      INC      (HL)        ; Increment exponent
 3258 1586 C0                      RET      NZ          ; Return if ok
 3259 1587 C39304                  JP       OVERR       ; Overflow error
 3260                   ;
 3261 158A 7E           PLUCDE:    LD       A,(HL)      ; Get LSB of FPREG
 3262 158B 83                      ADD      A,E         ; Add LSB of BCDE
 3263 158C 5F                      LD       E,A         ; Save LSB of BCDE
 3264 158D 23                      INC      HL
 3265 158E 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3266 158F 8A                      ADC      A,D         ; Add NMSB of BCDE
 3267 1590 57                      LD       D,A         ; Save NMSB of BCDE
 3268 1591 23                      INC      HL
 3269 1592 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3270 1593 89                      ADC      A,C         ; Add MSB of BCDE
 3271 1594 4F                      LD       C,A         ; Save MSB of BCDE
 3272 1595 C9                      RET
 3273                   ;
 3274 1596 212D81       COMPL:     LD       HL,SGNRES   ; Sign of result
 3275 1599 7E                      LD       A,(HL)      ; Get sign of result
 3276 159A 2F                      CPL                  ; Negate it
 3277 159B 77                      LD       (HL),A      ; Put it back
 3278 159C AF                      XOR      A
 3279 159D 6F                      LD       L,A         ; Set L to zero
 3280 159E 90                      SUB      B           ; Negate exponent,set c
 3281 159F 47                      LD       B,A         ; Re-save exponent
 3282 15A0 7D                      LD       A,L         ; Load zero
 3283 15A1 9B                      SBC      A,E         ; Negate LSB
 3284 15A2 5F                      LD       E,A         ; Re-save LSB
 3285 15A3 7D                      LD       A,L         ; Load zero
 3286 15A4 9A                      SBC      A,D         ; Negate NMSB
 3287 15A5 57                      LD       D,A         ; Re-save NMSB
 3288 15A6 7D                      LD       A,L         ; Load zero
 3289 15A7 99                      SBC      A,C         ; Negate MSB
 3290 15A8 4F                      LD       C,A         ; Re-save MSB
 3291 15A9 C9                      RET
 3292                   ;
 3293 15AA 0600         SCALE:     LD       B,0         ; Clear underflow
 3294 15AC D608         SCALLP:    SUB      8           ; 8 bits (a whole byte)
 3295 15AE DAB915                  JP       C,SHRITE    ; No - Shift right A bi
 3296 15B1 43                      LD       B,E         ; <- Shift
 3297 15B2 5A                      LD       E,D         ; <- right
 3298 15B3 51                      LD       D,C         ; <- eight
 3299 15B4 0E00                    LD       C,0         ; <- bits
 3300 15B6 C3AC15                  JP       SCALLP      ; More bits to shift
 3301                   ;
 3302 15B9 C609         SHRITE:    ADD      A,8+1       ; Adjust count
 3303 15BB 6F                      LD       L,A         ; Save bits to shift
 3304 15BC AF           SHRLP:     XOR      A           ; Flag for all done
 3305 15BD 2D                      DEC      L           ; All shifting done?
 3306 15BE C8                      RET      Z           ; Yes - Return
 3307 15BF 79                      LD       A,C         ; Get MSB
 3308 15C0 1F           SHRT1:     RRA                  ; Shift it right
 3309 15C1 4F                      LD       C,A         ; Re-save
 3310 15C2 7A                      LD       A,D         ; Get NMSB
 3311 15C3 1F                      RRA                  ; Shift right with last
 3312 15C4 57                      LD       D,A         ; Re-save it
 3313 15C5 7B                      LD       A,E         ; Get LSB
 3314 15C6 1F                      RRA                  ; Shift right with last
 3315 15C7 5F                      LD       E,A         ; Re-save it
 3316 15C8 78                      LD       A,B         ; Get underflow
 3317 15C9 1F                      RRA                  ; Shift right with last
 3318 15CA 47                      LD       B,A         ; Re-save underflow
 3319 15CB C3BC15                  JP       SHRLP       ; More bits to do
 3320                   ;
 3321 15CE 00000081     UNITY:     DB       000H,000H,000H,081H ; 1.00000
 3322                   ;
 3323 15D2 03           LOGTAB:    DB       3           ; Table used by LOG
 3324 15D3 AA561980                DB       0AAH,056H,019H,080H ; 0.59898
 3325 15D7 F1227680                DB       0F1H,022H,076H,080H ; 0.96147
 3326 15DB 45AA3882                DB       045H,0AAH,038H,082H ; 2.88539
 3327                   ;
 3328 15DF CD2B17       LOG:       CALL     TSTSGN      ; Test sign of value
 3329 15E2 B7                      OR       A
 3330 15E3 EAA309                  JP       PE,FCERR    ; ?FC Error if <= zero
 3331 15E6 212C81                  LD       HL,FPEXP    ; Point to exponent
 3332 15E9 7E                      LD       A,(HL)      ; Get exponent
 3333 15EA 013580                  LD       BC,8035H    ; BCDE = SQR(1/2)
 3334 15ED 11F304                  LD       DE,04F3H
 3335 15F0 90                      SUB      B           ; Scale value to be < 1
 3336 15F1 F5                      PUSH     AF          ; Save scale factor
 3337 15F2 70                      LD       (HL),B      ; Save new exponent
 3338 15F3 D5                      PUSH     DE          ; Save SQR(1/2)
 3339 15F4 C5                      PUSH     BC
 3340 15F5 CDE514                  CALL     FPADD       ; Add SQR(1/2) to value
 3341 15F8 C1                      POP      BC          ; Restore SQR(1/2)
 3342 15F9 D1                      POP      DE
 3343 15FA 04                      INC      B           ; Make it SQR(2)
 3344 15FB CD8116                  CALL     DVBCDE      ; Divide by SQR(2)
 3345 15FE 21CE15                  LD       HL,UNITY    ; Point to 1.
 3346 1601 CDDC14                  CALL     SUBPHL      ; Subtract FPREG from 1
 3347 1604 21D215                  LD       HL,LOGTAB   ; Coefficient table
 3348 1607 CD731A                  CALL     SUMSER      ; Evaluate sum of serie
 3349 160A 018080                  LD       BC,8080H    ; BCDE = -0.5
 3350 160D 110000                  LD       DE,0000H
 3351 1610 CDE514                  CALL     FPADD       ; Subtract 0.5 from FPR
 3352 1613 F1                      POP      AF          ; Restore scale factor
 3353 1614 CDA618                  CALL     RSCALE      ; Re-scale number
 3354 1617 013180       MULLN2:    LD       BC,8031H    ; BCDE = Ln(2)
 3355 161A 111872                  LD       DE,7218H
 3356 161D 21                      DB       21H         ; Skip "POP BC" and "PO
 3357                   ;
 3358 161E C1           MULT:      POP      BC          ; Get number from stack
 3359 161F D1                      POP      DE
 3360 1620 CD2B17       FPMULT:    CALL     TSTSGN      ; Test sign of FPREG
 3361 1623 C8                      RET      Z           ; Return zero if zero
 3362 1624 2E00                    LD       L,0         ; Flag add exponents
 3363 1626 CDE916                  CALL     ADDEXP      ; Add exponents
 3364 1629 79                      LD       A,C         ; Get MSB of multiplier
 3365 162A 323B81                  LD       (MULVAL),A  ; Save MSB of multiplie
 3366 162D EB                      EX       DE,HL
 3367 162E 223C81                  LD       (MULVAL+1),HL ; Save rest of multip
 3368 1631 010000                  LD       BC,0        ; Partial product (BCDE
 3369 1634 50                      LD       D,B
 3370 1635 58                      LD       E,B
 3371 1636 213615                  LD       HL,BNORM    ; Address of normalise
 3372 1639 E5                      PUSH     HL          ; Save for return
 3373 163A 214216                  LD       HL,MULT8    ; Address of 8 bit mult
 3374 163D E5                      PUSH     HL          ; Save for NMSB,MSB
 3375 163E E5                      PUSH     HL          ;
 3376 163F 212981                  LD       HL,FPREG    ; Point to number
 3377 1642 7E           MULT8:     LD       A,(HL)      ; Get LSB of number
 3378 1643 23                      INC      HL          ; Point to NMSB
 3379 1644 B7                      OR       A           ; Test LSB
 3380 1645 CA6E16                  JP       Z,BYTSFT    ; Zero - shift to next 
 3381 1648 E5                      PUSH     HL          ; Save address of numbe
 3382 1649 2E08                    LD       L,8         ; 8 bits to multiply by
 3383 164B 1F           MUL8LP:    RRA                  ; Shift LSB right
 3384 164C 67                      LD       H,A         ; Save LSB
 3385 164D 79                      LD       A,C         ; Get MSB
 3386 164E D25C16                  JP       NC,NOMADD   ; Bit was zero - Don't 
 3387 1651 E5                      PUSH     HL          ; Save LSB and count
 3388 1652 2A3C81                  LD       HL,(MULVAL+1) ; Get LSB and NMSB
 3389 1655 19                      ADD      HL,DE       ; Add NMSB and LSB
 3390 1656 EB                      EX       DE,HL       ; Leave sum in DE
 3391 1657 E1                      POP      HL          ; Restore MSB and count
 3392 1658 3A3B81                  LD       A,(MULVAL)  ; Get MSB of multiplier
 3393 165B 89                      ADC      A,C         ; Add MSB
 3394 165C 1F           NOMADD:    RRA                  ; Shift MSB right
 3395 165D 4F                      LD       C,A         ; Re-save MSB
 3396 165E 7A                      LD       A,D         ; Get NMSB
 3397 165F 1F                      RRA                  ; Shift NMSB right
 3398 1660 57                      LD       D,A         ; Re-save NMSB
 3399 1661 7B                      LD       A,E         ; Get LSB
 3400 1662 1F                      RRA                  ; Shift LSB right
 3401 1663 5F                      LD       E,A         ; Re-save LSB
 3402 1664 78                      LD       A,B         ; Get VLSB
 3403 1665 1F                      RRA                  ; Shift VLSB right
 3404 1666 47                      LD       B,A         ; Re-save VLSB
 3405 1667 2D                      DEC      L           ; Count bits multiplied
 3406 1668 7C                      LD       A,H         ; Get LSB of multiplier
 3407 1669 C24B16                  JP       NZ,MUL8LP   ; More - Do it
 3408 166C E1           POPHRT:    POP      HL          ; Restore address of nu
 3409 166D C9                      RET
 3410                   ;
 3411 166E 43           BYTSFT:    LD       B,E         ; Shift partial product
 3412 166F 5A                      LD       E,D
 3413 1670 51                      LD       D,C
 3414 1671 4F                      LD       C,A
 3415 1672 C9                      RET
 3416                   ;
 3417 1673 CD5C17       DIV10:     CALL     STAKFP      ; Save FPREG on stack
 3418 1676 012084                  LD       BC,8420H    ; BCDE = 10.
 3419 1679 110000                  LD       DE,0000H
 3420 167C CD6C17                  CALL     FPBCDE      ; Move 10 to FPREG
 3421                   ;
 3422 167F C1           DIV:       POP      BC          ; Get number from stack
 3423 1680 D1                      POP      DE
 3424 1681 CD2B17       DVBCDE:    CALL     TSTSGN      ; Test sign of FPREG
 3425 1684 CA8704                  JP       Z,DZERR     ; Error if division by 
 3426 1687 2EFF                    LD       L,-1        ; Flag subtract exponen
 3427 1689 CDE916                  CALL     ADDEXP      ; Subtract exponents
 3428 168C 34                      INC      (HL)        ; Add 2 to exponent to 
 3429 168D 34                      INC      (HL)
 3430 168E 2B                      DEC      HL          ; Point to MSB
 3431 168F 7E                      LD       A,(HL)      ; Get MSB of dividend
 3432 1690 325780                  LD       (DIV3),A    ; Save for subtraction
 3433 1693 2B                      DEC      HL
 3434 1694 7E                      LD       A,(HL)      ; Get NMSB of dividend
 3435 1695 325380                  LD       (DIV2),A    ; Save for subtraction
 3436 1698 2B                      DEC      HL
 3437 1699 7E                      LD       A,(HL)      ; Get MSB of dividend
 3438 169A 324F80                  LD       (DIV1),A    ; Save for subtraction
 3439 169D 41                      LD       B,C         ; Get MSB
 3440 169E EB                      EX       DE,HL       ; NMSB,LSB to HL
 3441 169F AF                      XOR      A
 3442 16A0 4F                      LD       C,A         ; Clear MSB of quotient
 3443 16A1 57                      LD       D,A         ; Clear NMSB of quotien
 3444 16A2 5F                      LD       E,A         ; Clear LSB of quotient
 3445 16A3 325A80                  LD       (DIV4),A    ; Clear overflow count
 3446 16A6 E5           DIVLP:     PUSH     HL          ; Save divisor
 3447 16A7 C5                      PUSH     BC
 3448 16A8 7D                      LD       A,L         ; Get LSB of number
 3449 16A9 CD4E80                  CALL     DIVSUP      ; Subt' divisor from di
 3450 16AC DE00                    SBC      A,0         ; Count for overflows
 3451 16AE 3F                      CCF
 3452 16AF D2B916                  JP       NC,RESDIV   ; Restore divisor if bo
 3453 16B2 325A80                  LD       (DIV4),A    ; Re-save overflow coun
 3454 16B5 F1                      POP      AF          ; Scrap divisor
 3455 16B6 F1                      POP      AF
 3456 16B7 37                      SCF                  ; Set carry to
 3457 16B8 D2                      DB       0D2H        ; Skip "POP BC" and "PO
 3458                   ;
 3459 16B9 C1           RESDIV:    POP      BC          ; Restore divisor
 3460 16BA E1                      POP      HL
 3461 16BB 79                      LD       A,C         ; Get MSB of quotient
 3462 16BC 3C                      INC      A
 3463 16BD 3D                      DEC      A
 3464 16BE 1F                      RRA                  ; Bit 0 to bit 7
 3465 16BF FA6C15                  JP       M,RONDB     ; Done - Normalise resu
 3466 16C2 17                      RLA                  ; Restore carry
 3467 16C3 7B                      LD       A,E         ; Get LSB of quotient
 3468 16C4 17                      RLA                  ; Double it
 3469 16C5 5F                      LD       E,A         ; Put it back
 3470 16C6 7A                      LD       A,D         ; Get NMSB of quotient
 3471 16C7 17                      RLA                  ; Double it
 3472 16C8 57                      LD       D,A         ; Put it back
 3473 16C9 79                      LD       A,C         ; Get MSB of quotient
 3474 16CA 17                      RLA                  ; Double it
 3475 16CB 4F                      LD       C,A         ; Put it back
 3476 16CC 29                      ADD      HL,HL       ; Double NMSB,LSB of di
 3477 16CD 78                      LD       A,B         ; Get MSB of divisor
 3478 16CE 17                      RLA                  ; Double it
 3479 16CF 47                      LD       B,A         ; Put it back
 3480 16D0 3A5A80                  LD       A,(DIV4)    ; Get VLSB of quotient
 3481 16D3 17                      RLA                  ; Double it
 3482 16D4 325A80                  LD       (DIV4),A    ; Put it back
 3483 16D7 79                      LD       A,C         ; Get MSB of quotient
 3484 16D8 B2                      OR       D           ; Merge NMSB
 3485 16D9 B3                      OR       E           ; Merge LSB
 3486 16DA C2A616                  JP       NZ,DIVLP    ; Not done - Keep divid
 3487 16DD E5                      PUSH     HL          ; Save divisor
 3488 16DE 212C81                  LD       HL,FPEXP    ; Point to exponent
 3489 16E1 35                      DEC      (HL)        ; Divide by 2
 3490 16E2 E1                      POP      HL          ; Restore divisor
 3491 16E3 C2A616                  JP       NZ,DIVLP    ; Ok - Keep going
 3492 16E6 C39304                  JP       OVERR       ; Overflow error
 3493                   ;
 3494 16E9 78           ADDEXP:    LD       A,B         ; Get exponent of divid
 3495 16EA B7                      OR       A           ; Test it
 3496 16EB CA0D17                  JP       Z,OVTST3    ; Zero - Result zero
 3497 16EE 7D                      LD       A,L         ; Get add/subtract flag
 3498 16EF 212C81                  LD       HL,FPEXP    ; Point to exponent
 3499 16F2 AE                      XOR      (HL)        ; Add or subtract it
 3500 16F3 80                      ADD      A,B         ; Add the other exponen
 3501 16F4 47                      LD       B,A         ; Save new exponent
 3502 16F5 1F                      RRA                  ; Test exponent for ove
 3503 16F6 A8                      XOR      B
 3504 16F7 78                      LD       A,B         ; Get exponent
 3505 16F8 F20C17                  JP       P,OVTST2    ; Positive - Test for o
 3506 16FB C680                    ADD      A,80H       ; Add excess 128
 3507 16FD 77                      LD       (HL),A      ; Save new exponent
 3508 16FE CA6C16                  JP       Z,POPHRT    ; Zero - Result zero
 3509 1701 CD9117                  CALL     SIGNS       ; Set MSBs and sign of 
 3510 1704 77                      LD       (HL),A      ; Save new exponent
 3511 1705 2B                      DEC      HL          ; Point to MSB
 3512 1706 C9                      RET
 3513                   ;
 3514 1707 CD2B17       OVTST1:    CALL     TSTSGN      ; Test sign of FPREG
 3515 170A 2F                      CPL                  ; Invert sign
 3516 170B E1                      POP      HL          ; Clean up stack
 3517 170C B7           OVTST2:    OR       A           ; Test if new exponent 
 3518 170D E1           OVTST3:    POP      HL          ; Clear off return addr
 3519 170E F24B15                  JP       P,RESZER    ; Result zero
 3520 1711 C39304                  JP       OVERR       ; Overflow error
 3521                   ;
 3522 1714 CD7717       MLSP10:    CALL     BCDEFP      ; Move FPREG to BCDE
 3523 1717 78                      LD       A,B         ; Get exponent
 3524 1718 B7                      OR       A           ; Is it zero?
 3525 1719 C8                      RET      Z           ; Yes - Result is zero
 3526 171A C602                    ADD      A,2         ; Multiply by 4
 3527 171C DA9304                  JP       C,OVERR     ; Overflow - ?OV Error
 3528 171F 47                      LD       B,A         ; Re-save exponent
 3529 1720 CDE514                  CALL     FPADD       ; Add BCDE to FPREG (Ti
 3530 1723 212C81                  LD       HL,FPEXP    ; Point to exponent
 3531 1726 34                      INC      (HL)        ; Double number (Times 
 3532 1727 C0                      RET      NZ          ; Ok - Return
 3533 1728 C39304                  JP       OVERR       ; Overflow error
 3534                   ;
 3535 172B 3A2C81       TSTSGN:    LD       A,(FPEXP)   ; Get sign of FPREG
 3536 172E B7                      OR       A
 3537 172F C8                      RET      Z           ; RETurn if number is z
 3538 1730 3A2B81                  LD       A,(FPREG+2) ; Get MSB of FPREG
 3539 1733 FE                      DB       0FEH        ; Test sign
 3540 1734 2F           RETREL:    CPL                  ; Invert sign
 3541 1735 17                      RLA                  ; Sign bit to carry
 3542 1736 9F           FLGDIF:    SBC      A,A         ; Carry to all bits of 
 3543 1737 C0                      RET      NZ          ; Return -1 if negative
 3544 1738 3C                      INC      A           ; Bump to +1
 3545 1739 C9                      RET                  ; Positive - Return +1
 3546                   ;
 3547 173A CD2B17       SGN:       CALL     TSTSGN      ; Test sign of FPREG
 3548 173D 0688         FLGREL:    LD       B,80H+8     ; 8 bit integer in expo
 3549 173F 110000                  LD       DE,0        ; Zero NMSB and LSB
 3550 1742 212C81       RETINT:    LD       HL,FPEXP    ; Point to exponent
 3551 1745 4F                      LD       C,A         ; CDE = MSB,NMSB and LS
 3552 1746 70                      LD       (HL),B      ; Save exponent
 3553 1747 0600                    LD       B,0         ; CDE = integer to norm
 3554 1749 23                      INC      HL          ; Point to sign of resu
 3555 174A 3680                    LD       (HL),80H    ; Set sign of result
 3556 174C 17                      RLA                  ; Carry = sign of integ
 3557 174D C33315                  JP       CONPOS      ; Set sign of result
 3558                   ;
 3559 1750 CD2B17       ABS:       CALL     TSTSGN      ; Test sign of FPREG
 3560 1753 F0                      RET      P           ; Return if positive
 3561 1754 212B81       INVSGN:    LD       HL,FPREG+2  ; Point to MSB
 3562 1757 7E                      LD       A,(HL)      ; Get sign of mantissa
 3563 1758 EE80                    XOR      80H         ; Invert sign of mantis
 3564 175A 77                      LD       (HL),A      ; Re-save sign of manti
 3565 175B C9                      RET
 3566                   ;
 3567 175C EB           STAKFP:    EX       DE,HL       ; Save code string addr
 3568 175D 2A2981                  LD       HL,(FPREG)  ; LSB,NLSB of FPREG
 3569 1760 E3                      EX       (SP),HL     ; Stack them,get return
 3570 1761 E5                      PUSH     HL          ; Re-save return
 3571 1762 2A2B81                  LD       HL,(FPREG+2) ; MSB and exponent of 
 3572 1765 E3                      EX       (SP),HL     ; Stack them,get return
 3573 1766 E5                      PUSH     HL          ; Re-save return
 3574 1767 EB                      EX       DE,HL       ; Restore code string a
 3575 1768 C9                      RET
 3576                   ;
 3577 1769 CD7A17       PHLTFP:    CALL     LOADFP      ; Number at HL to BCDE
 3578 176C EB           FPBCDE:    EX       DE,HL       ; Save code string addr
 3579 176D 222981                  LD       (FPREG),HL  ; Save LSB,NLSB of numb
 3580 1770 60                      LD       H,B         ; Exponent of number
 3581 1771 69                      LD       L,C         ; MSB of number
 3582 1772 222B81                  LD       (FPREG+2),HL ; Save MSB and exponen
 3583 1775 EB                      EX       DE,HL       ; Restore code string a
 3584 1776 C9                      RET
 3585                   ;
 3586 1777 212981       BCDEFP:    LD       HL,FPREG    ; Point to FPREG
 3587 177A 5E           LOADFP:    LD       E,(HL)      ; Get LSB of number
 3588 177B 23                      INC      HL
 3589 177C 56                      LD       D,(HL)      ; Get NMSB of number
 3590 177D 23                      INC      HL
 3591 177E 4E                      LD       C,(HL)      ; Get MSB of number
 3592 177F 23                      INC      HL
 3593 1780 46                      LD       B,(HL)      ; Get exponent of numbe
 3594 1781 23           INCHL:     INC      HL          ; Used for conditional 
 3595 1782 C9                      RET
 3596                   ;
 3597 1783 112981       FPTHL:     LD       DE,FPREG    ; Point to FPREG
 3598 1786 0604         DETHL4:    LD       B,4         ; 4 bytes to move
 3599 1788 1A           DETHLB:    LD       A,(DE)      ; Get source
 3600 1789 77                      LD       (HL),A      ; Save destination
 3601 178A 13                      INC      DE          ; Next source
 3602 178B 23                      INC      HL          ; Next destination
 3603 178C 05                      DEC      B           ; Count bytes
 3604 178D C28817                  JP       NZ,DETHLB   ; Loop if more
 3605 1790 C9                      RET
 3606                   ;
 3607 1791 212B81       SIGNS:     LD       HL,FPREG+2  ; Point to MSB of FPREG
 3608 1794 7E                      LD       A,(HL)      ; Get MSB
 3609 1795 07                      RLCA                 ; Old sign to carry
 3610 1796 37                      SCF                  ; Set MSBit
 3611 1797 1F                      RRA                  ; Set MSBit of MSB
 3612 1798 77                      LD       (HL),A      ; Save new MSB
 3613 1799 3F                      CCF                  ; Complement sign
 3614 179A 1F                      RRA                  ; Old sign to carry
 3615 179B 23                      INC      HL
 3616 179C 23                      INC      HL
 3617 179D 77                      LD       (HL),A      ; Set sign of result
 3618 179E 79                      LD       A,C         ; Get MSB
 3619 179F 07                      RLCA                 ; Old sign to carry
 3620 17A0 37                      SCF                  ; Set MSBit
 3621 17A1 1F                      RRA                  ; Set MSBit of MSB
 3622 17A2 4F                      LD       C,A         ; Save MSB
 3623 17A3 1F                      RRA
 3624 17A4 AE                      XOR      (HL)        ; New sign of result
 3625 17A5 C9                      RET
 3626                   ;
 3627 17A6 78           CMPNUM:    LD       A,B         ; Get exponent of numbe
 3628 17A7 B7                      OR       A
 3629 17A8 CA2B17                  JP       Z,TSTSGN    ; Zero - Test sign of F
 3630 17AB 213417                  LD       HL,RETREL   ; Return relation routi
 3631 17AE E5                      PUSH     HL          ; Save for return
 3632 17AF CD2B17                  CALL     TSTSGN      ; Test sign of FPREG
 3633 17B2 79                      LD       A,C         ; Get MSB of number
 3634 17B3 C8                      RET      Z           ; FPREG zero - Number's
 3635 17B4 212B81                  LD       HL,FPREG+2  ; MSB of FPREG
 3636 17B7 AE                      XOR      (HL)        ; Combine signs
 3637 17B8 79                      LD       A,C         ; Get MSB of number
 3638 17B9 F8                      RET      M           ; Exit if signs differe
 3639 17BA CDC017                  CALL     CMPFP       ; Compare FP numbers
 3640 17BD 1F                      RRA                  ; Get carry to sign
 3641 17BE A9                      XOR      C           ; Combine with MSB of n
 3642 17BF C9                      RET
 3643                   ;
 3644 17C0 23           CMPFP:     INC      HL          ; Point to exponent
 3645 17C1 78                      LD       A,B         ; Get exponent
 3646 17C2 BE                      CP       (HL)        ; Compare exponents
 3647 17C3 C0                      RET      NZ          ; Different
 3648 17C4 2B                      DEC      HL          ; Point to MBS
 3649 17C5 79                      LD       A,C         ; Get MSB
 3650 17C6 BE                      CP       (HL)        ; Compare MSBs
 3651 17C7 C0                      RET      NZ          ; Different
 3652 17C8 2B                      DEC      HL          ; Point to NMSB
 3653 17C9 7A                      LD       A,D         ; Get NMSB
 3654 17CA BE                      CP       (HL)        ; Compare NMSBs
 3655 17CB C0                      RET      NZ          ; Different
 3656 17CC 2B                      DEC      HL          ; Point to LSB
 3657 17CD 7B                      LD       A,E         ; Get LSB
 3658 17CE 96                      SUB      (HL)        ; Compare LSBs
 3659 17CF C0                      RET      NZ          ; Different
 3660 17D0 E1                      POP      HL          ; Drop RETurn
 3661 17D1 E1                      POP      HL          ; Drop another RETurn
 3662 17D2 C9                      RET
 3663                   ;
 3664 17D3 47           FPINT:     LD       B,A         ; <- Move
 3665 17D4 4F                      LD       C,A         ; <- exponent
 3666 17D5 57                      LD       D,A         ; <- to all
 3667 17D6 5F                      LD       E,A         ; <- bits
 3668 17D7 B7                      OR       A           ; Test exponent
 3669 17D8 C8                      RET      Z           ; Zero - Return zero
 3670 17D9 E5                      PUSH     HL          ; Save pointer to numbe
 3671 17DA CD7717                  CALL     BCDEFP      ; Move FPREG to BCDE
 3672 17DD CD9117                  CALL     SIGNS       ; Set MSBs & sign of re
 3673 17E0 AE                      XOR      (HL)        ; Combine with sign of 
 3674 17E1 67                      LD       H,A         ; Save combined signs
 3675 17E2 FCF717                  CALL     M,DCBCDE    ; Negative - Decrement 
 3676 17E5 3E98                    LD       A,80H+24    ; 24 bits
 3677 17E7 90                      SUB      B           ; Bits to shift
 3678 17E8 CDAA15                  CALL     SCALE       ; Shift BCDE
 3679 17EB 7C                      LD       A,H         ; Get combined sign
 3680 17EC 17                      RLA                  ; Sign to carry
 3681 17ED DC7D15                  CALL     C,FPROND    ; Negative - Round numb
 3682 17F0 0600                    LD       B,0         ; Zero exponent
 3683 17F2 DC9615                  CALL     C,COMPL     ; If negative make posi
 3684 17F5 E1                      POP      HL          ; Restore pointer to nu
 3685 17F6 C9                      RET
 3686                   ;
 3687 17F7 1B           DCBCDE:    DEC      DE          ; Decrement BCDE
 3688 17F8 7A                      LD       A,D         ; Test LSBs
 3689 17F9 A3                      AND      E
 3690 17FA 3C                      INC      A
 3691 17FB C0                      RET      NZ          ; Exit if LSBs not FFFF
 3692 17FC 0B                      DEC      BC          ; Decrement MSBs
 3693 17FD C9                      RET
 3694                   ;
 3695 17FE 212C81       INT:       LD       HL,FPEXP    ; Point to exponent
 3696 1801 7E                      LD       A,(HL)      ; Get exponent
 3697 1802 FE98                    CP       80H+24      ; Integer accuracy only
 3698 1804 3A2981                  LD       A,(FPREG)   ; Get LSB
 3699 1807 D0                      RET      NC          ; Yes - Already integer
 3700 1808 7E                      LD       A,(HL)      ; Get exponent
 3701 1809 CDD317                  CALL     FPINT       ; F.P to integer
 3702 180C 3698                    LD       (HL),80H+24 ; Save 24 bit integer
 3703 180E 7B                      LD       A,E         ; Get LSB of number
 3704 180F F5                      PUSH     AF          ; Save LSB
 3705 1810 79                      LD       A,C         ; Get MSB of number
 3706 1811 17                      RLA                  ; Sign to carry
 3707 1812 CD3315                  CALL     CONPOS      ; Set sign of result
 3708 1815 F1                      POP      AF          ; Restore LSB of number
 3709 1816 C9                      RET
 3710                   ;
 3711 1817 210000       MLDEBC:    LD       HL,0        ; Clear partial product
 3712 181A 78                      LD       A,B         ; Test multiplier
 3713 181B B1                      OR       C
 3714 181C C8                      RET      Z           ; Return zero if zero
 3715 181D 3E10                    LD       A,16        ; 16 bits
 3716 181F 29           MLDBLP:    ADD      HL,HL       ; Shift P.P left
 3717 1820 DA5710                  JP       C,BSERR     ; ?BS Error if overflow
 3718 1823 EB                      EX       DE,HL
 3719 1824 29                      ADD      HL,HL       ; Shift multiplier left
 3720 1825 EB                      EX       DE,HL
 3721 1826 D22D18                  JP       NC,NOMLAD   ; Bit was zero - No add
 3722 1829 09                      ADD      HL,BC       ; Add multiplicand
 3723 182A DA5710                  JP       C,BSERR     ; ?BS Error if overflow
 3724 182D 3D           NOMLAD:    DEC      A           ; Count bits
 3725 182E C21F18                  JP       NZ,MLDBLP   ; More
 3726 1831 C9                      RET
 3727                   ;
 3728 1832 FE2D         ASCTFP:    CP       '-'         ; Negative?
 3729 1834 F5                      PUSH     AF          ; Save it and flags
 3730 1835 CA3E18                  JP       Z,CNVNUM    ; Yes - Convert number
 3731 1838 FE2B                    CP       '+'         ; Positive?
 3732 183A CA3E18                  JP       Z,CNVNUM    ; Yes - Convert number
 3733 183D 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3734 183E CD4B15       CNVNUM:    CALL     RESZER      ; Set result to zero
 3735 1841 47                      LD       B,A         ; Digits after point co
 3736 1842 57                      LD       D,A         ; Sign of exponent
 3737 1843 5F                      LD       E,A         ; Exponent of ten
 3738 1844 2F                      CPL
 3739 1845 4F                      LD       C,A         ; Before or after point
 3740 1846 CDDC08       MANLP:     CALL     GETCHR      ; Get next character
 3741 1849 DA8F18                  JP       C,ADDIG     ; Digit - Add to number
 3742 184C FE2E                    CP       '.'
 3743 184E CA6A18                  JP       Z,DPOINT    ; '.' - Flag point
 3744 1851 FE45                    CP       'E'
 3745 1853 C26E18                  JP       NZ,CONEXP   ; Not 'E' - Scale numbe
 3746 1856 CDDC08                  CALL     GETCHR      ; Get next character
 3747 1859 CD820E                  CALL     SGNEXP      ; Get sign of exponent
 3748 185C CDDC08       EXPLP:     CALL     GETCHR      ; Get next character
 3749 185F DAB118                  JP       C,EDIGIT    ; Digit - Add to expone
 3750 1862 14                      INC      D           ; Is sign negative?
 3751 1863 C26E18                  JP       NZ,CONEXP   ; No - Scale number
 3752 1866 AF                      XOR      A
 3753 1867 93                      SUB      E           ; Negate exponent
 3754 1868 5F                      LD       E,A         ; And re-save it
 3755 1869 0C                      INC      C           ; Flag end of number
 3756 186A 0C           DPOINT:    INC      C           ; Flag point passed
 3757 186B CA4618                  JP       Z,MANLP     ; Zero - Get another di
 3758 186E E5           CONEXP:    PUSH     HL          ; Save code string addr
 3759 186F 7B                      LD       A,E         ; Get exponent
 3760 1870 90                      SUB      B           ; Subtract digits after
 3761 1871 F48718       SCALMI:    CALL     P,SCALPL    ; Positive - Multiply n
 3762 1874 F27D18                  JP       P,ENDCON    ; Positive - All done
 3763 1877 F5                      PUSH     AF          ; Save number of times 
 3764 1878 CD7316                  CALL     DIV10       ; Divide by 10
 3765 187B F1                      POP      AF          ; Restore count
 3766 187C 3C                      INC      A           ; Count divides
 3767                   ;
 3768 187D C27118       ENDCON:    JP       NZ,SCALMI   ; More to do
 3769 1880 D1                      POP      DE          ; Restore code string a
 3770 1881 F1                      POP      AF          ; Restore sign of numbe
 3771 1882 CC5417                  CALL     Z,INVSGN    ; Negative - Negate num
 3772 1885 EB                      EX       DE,HL       ; Code string address t
 3773 1886 C9                      RET
 3774                   ;
 3775 1887 C8           SCALPL:    RET      Z           ; Exit if no scaling ne
 3776 1888 F5           MULTEN:    PUSH     AF          ; Save count
 3777 1889 CD1417                  CALL     MLSP10      ; Multiply number by 10
 3778 188C F1                      POP      AF          ; Restore count
 3779 188D 3D                      DEC      A           ; Count multiplies
 3780 188E C9                      RET
 3781                   ;
 3782 188F D5           ADDIG:     PUSH     DE          ; Save sign of exponent
 3783 1890 57                      LD       D,A         ; Save digit
 3784 1891 78                      LD       A,B         ; Get digits after poin
 3785 1892 89                      ADC      A,C         ; Add one if after poin
 3786 1893 47                      LD       B,A         ; Re-save counter
 3787 1894 C5                      PUSH     BC          ; Save point flags
 3788 1895 E5                      PUSH     HL          ; Save code string addr
 3789 1896 D5                      PUSH     DE          ; Save digit
 3790 1897 CD1417                  CALL     MLSP10      ; Multiply number by 10
 3791 189A F1                      POP      AF          ; Restore digit
 3792 189B D630                    SUB      '0'         ; Make it absolute
 3793 189D CDA618                  CALL     RSCALE      ; Re-scale number
 3794 18A0 E1                      POP      HL          ; Restore code string a
 3795 18A1 C1                      POP      BC          ; Restore point flags
 3796 18A2 D1                      POP      DE          ; Restore sign of expon
 3797 18A3 C34618                  JP       MANLP       ; Get another digit
 3798                   ;
 3799 18A6 CD5C17       RSCALE:    CALL     STAKFP      ; Put number on stack
 3800 18A9 CD3D17                  CALL     FLGREL      ; Digit to add to FPREG
 3801 18AC C1           PADD:      POP      BC          ; Restore number
 3802 18AD D1                      POP      DE
 3803 18AE C3E514                  JP       FPADD       ; Add BCDE to FPREG and
 3804                   ;
 3805 18B1 7B           EDIGIT:    LD       A,E         ; Get digit
 3806 18B2 07                      RLCA                 ; Times 2
 3807 18B3 07                      RLCA                 ; Times 4
 3808 18B4 83                      ADD      A,E         ; Times 5
 3809 18B5 07                      RLCA                 ; Times 10
 3810 18B6 86                      ADD      A,(HL)      ; Add next digit
 3811 18B7 D630                    SUB      '0'         ; Make it absolute
 3812 18B9 5F                      LD       E,A         ; Save new digit
 3813 18BA C35C18                  JP       EXPLP       ; Look for another digi
 3814                   ;
 3815 18BD E5           LINEIN:    PUSH     HL          ; Save code string addr
 3816 18BE 211C04                  LD       HL,INMSG    ; Output " in "
 3817 18C1 CD2212                  CALL     PRS         ; Output string at HL
 3818 18C4 E1                      POP      HL          ; Restore code string a
 3819 18C5 EB           PRNTHL:    EX       DE,HL       ; Code string address t
 3820 18C6 AF                      XOR      A
 3821 18C7 0698                    LD       B,80H+24    ; 24 bits
 3822 18C9 CD4217                  CALL     RETINT      ; Return the integer
 3823 18CC 212112                  LD       HL,PRNUMS   ; Print number string
 3824 18CF E5                      PUSH     HL          ; Save for return
 3825 18D0 212E81       NUMASC:    LD       HL,PBUFF    ; Convert number to ASC
 3826 18D3 E5                      PUSH     HL          ; Save for return
 3827 18D4 CD2B17                  CALL     TSTSGN      ; Test sign of FPREG
 3828 18D7 3620                    LD       (HL),' '    ; Space at start
 3829 18D9 F2DE18                  JP       P,SPCFST    ; Positive - Space to s
 3830 18DC 362D                    LD       (HL),'-'    ; '-' sign at start
 3831 18DE 23           SPCFST:    INC      HL          ; First byte of number
 3832 18DF 3630                    LD       (HL),'0'    ; '0' if zero
 3833 18E1 CA9419                  JP       Z,JSTZER    ; Return '0' if zero
 3834 18E4 E5                      PUSH     HL          ; Save buffer address
 3835 18E5 FC5417                  CALL     M,INVSGN    ; Negate FPREG if negat
 3836 18E8 AF                      XOR      A           ; Zero A
 3837 18E9 F5                      PUSH     AF          ; Save it
 3838 18EA CD9A19                  CALL     RNGTST      ; Test number is in ran
 3839 18ED 014391       SIXDIG:    LD       BC,9143H    ; BCDE - 99999.9
 3840 18F0 11F84F                  LD       DE,4FF8H
 3841 18F3 CDA617                  CALL     CMPNUM      ; Compare numbers
 3842 18F6 B7                      OR       A
 3843 18F7 E20B19                  JP       PO,INRNG    ; > 99999.9 - Sort it o
 3844 18FA F1                      POP      AF          ; Restore count
 3845 18FB CD8818                  CALL     MULTEN      ; Multiply by ten
 3846 18FE F5                      PUSH     AF          ; Re-save count
 3847 18FF C3ED18                  JP       SIXDIG      ; Test it again
 3848                   ;
 3849 1902 CD7316       GTSIXD:    CALL     DIV10       ; Divide by 10
 3850 1905 F1                      POP      AF          ; Get count
 3851 1906 3C                      INC      A           ; Count divides
 3852 1907 F5                      PUSH     AF          ; Re-save count
 3853 1908 CD9A19                  CALL     RNGTST      ; Test number is in ran
 3854 190B CDD314       INRNG:     CALL     ROUND       ; Add 0.5 to FPREG
 3855 190E 3C                      INC      A
 3856 190F CDD317                  CALL     FPINT       ; F.P to integer
 3857 1912 CD6C17                  CALL     FPBCDE      ; Move BCDE to FPREG
 3858 1915 010603                  LD       BC,0306H    ; 1E+06 to 1E-03 range
 3859 1918 F1                      POP      AF          ; Restore count
 3860 1919 81                      ADD      A,C         ; 6 digits before point
 3861 191A 3C                      INC      A           ; Add one
 3862 191B FA2719                  JP       M,MAKNUM    ; Do it in 'E' form if 
 3863 191E FE08                    CP       6+1+1       ; More than 999999 ?
 3864 1920 D22719                  JP       NC,MAKNUM   ; Yes - Do it in 'E' fo
 3865 1923 3C                      INC      A           ; Adjust for exponent
 3866 1924 47                      LD       B,A         ; Exponent of number
 3867 1925 3E02                    LD       A,2         ; Make it zero after
 3868                   ;
 3869 1927 3D           MAKNUM:    DEC      A           ; Adjust for digits to 
 3870 1928 3D                      DEC      A
 3871 1929 E1                      POP      HL          ; Restore buffer addres
 3872 192A F5                      PUSH     AF          ; Save count
 3873 192B 11AD19                  LD       DE,POWERS   ; Powers of ten
 3874 192E 05                      DEC      B           ; Count digits before p
 3875 192F C23819                  JP       NZ,DIGTXT   ; Not zero - Do number
 3876 1932 362E                    LD       (HL),'.'    ; Save point
 3877 1934 23                      INC      HL          ; Move on
 3878 1935 3630                    LD       (HL),'0'    ; Save zero
 3879 1937 23                      INC      HL          ; Move on
 3880 1938 05           DIGTXT:    DEC      B           ; Count digits before p
 3881 1939 362E                    LD       (HL),'.'    ; Save point in case
 3882 193B CC8117                  CALL     Z,INCHL     ; Last digit - move on
 3883 193E C5                      PUSH     BC          ; Save digits before po
 3884 193F E5                      PUSH     HL          ; Save buffer address
 3885 1940 D5                      PUSH     DE          ; Save powers of ten
 3886 1941 CD7717                  CALL     BCDEFP      ; Move FPREG to BCDE
 3887 1944 E1                      POP      HL          ; Powers of ten table
 3888 1945 062F                    LD       B, '0'-1    ; ASCII '0' - 1
 3889 1947 04           TRYAGN:    INC      B           ; Count subtractions
 3890 1948 7B                      LD       A,E         ; Get LSB
 3891 1949 96                      SUB      (HL)        ; Subtract LSB
 3892 194A 5F                      LD       E,A         ; Save LSB
 3893 194B 23                      INC      HL
 3894 194C 7A                      LD       A,D         ; Get NMSB
 3895 194D 9E                      SBC      A,(HL)      ; Subtract NMSB
 3896 194E 57                      LD       D,A         ; Save NMSB
 3897 194F 23                      INC      HL
 3898 1950 79                      LD       A,C         ; Get MSB
 3899 1951 9E                      SBC      A,(HL)      ; Subtract MSB
 3900 1952 4F                      LD       C,A         ; Save MSB
 3901 1953 2B                      DEC      HL          ; Point back to start
 3902 1954 2B                      DEC      HL
 3903 1955 D24719                  JP       NC,TRYAGN   ; No overflow - Try aga
 3904 1958 CD8A15                  CALL     PLUCDE      ; Restore number
 3905 195B 23                      INC      HL          ; Start of next number
 3906 195C CD6C17                  CALL     FPBCDE      ; Move BCDE to FPREG
 3907 195F EB                      EX       DE,HL       ; Save point in table
 3908 1960 E1                      POP      HL          ; Restore buffer addres
 3909 1961 70                      LD       (HL),B      ; Save digit in buffer
 3910 1962 23                      INC      HL          ; And move on
 3911 1963 C1                      POP      BC          ; Restore digit count
 3912 1964 0D                      DEC      C           ; Count digits
 3913 1965 C23819                  JP       NZ,DIGTXT   ; More - Do them
 3914 1968 05                      DEC      B           ; Any decimal part?
 3915 1969 CA7819                  JP       Z,DOEBIT    ; No - Do 'E' bit
 3916 196C 2B           SUPTLZ:    DEC      HL          ; Move back through buf
 3917 196D 7E                      LD       A,(HL)      ; Get character
 3918 196E FE30                    CP       '0'         ; '0' character?
 3919 1970 CA6C19                  JP       Z,SUPTLZ    ; Yes - Look back for m
 3920 1973 FE2E                    CP       '.'         ; A decimal point?
 3921 1975 C48117                  CALL     NZ,INCHL    ; Move back over digit
 3922                   ;
 3923 1978 F1           DOEBIT:    POP      AF          ; Get 'E' flag
 3924 1979 CA9719                  JP       Z,NOENED    ; No 'E' needed - End b
 3925 197C 3645                    LD       (HL),'E'    ; Put 'E' in buffer
 3926 197E 23                      INC      HL          ; And move on
 3927 197F 362B                    LD       (HL),'+'    ; Put '+' in buffer
 3928 1981 F28819                  JP       P,OUTEXP    ; Positive - Output exp
 3929 1984 362D                    LD       (HL),'-'    ; Put '-' in buffer
 3930 1986 2F                      CPL                  ; Negate exponent
 3931 1987 3C                      INC      A
 3932 1988 062F         OUTEXP:    LD       B,'0'-1     ; ASCII '0' - 1
 3933 198A 04           EXPTEN:    INC      B           ; Count subtractions
 3934 198B D60A                    SUB      10          ; Tens digit
 3935 198D D28A19                  JP       NC,EXPTEN   ; More to do
 3936 1990 C63A                    ADD      A,'0'+10    ; Restore and make ASCI
 3937 1992 23                      INC      HL          ; Move on
 3938 1993 70                      LD       (HL),B      ; Save MSB of exponent
 3939 1994 23           JSTZER:    INC      HL          ;
 3940 1995 77                      LD       (HL),A      ; Save LSB of exponent
 3941 1996 23                      INC      HL
 3942 1997 71           NOENED:    LD       (HL),C      ; Mark end of buffer
 3943 1998 E1                      POP      HL          ; Restore code string a
 3944 1999 C9                      RET
 3945                   ;
 3946 199A 017494       RNGTST:    LD       BC,9474H    ; BCDE = 999999.
 3947 199D 11F723                  LD       DE,23F7H
 3948 19A0 CDA617                  CALL     CMPNUM      ; Compare numbers
 3949 19A3 B7                      OR       A
 3950 19A4 E1                      POP      HL          ; Return address to HL
 3951 19A5 E20219                  JP       PO,GTSIXD   ; Too big - Divide by t
 3952 19A8 E9                      JP       (HL)        ; Otherwise return to c
 3953                   ;
 3954 19A9 00000080     HALF:      DB       00H,00H,00H,80H ; 0.5
 3955                   ;
 3956 19AD A08601       POWERS:    DB       0A0H,086H,001H ; 100000
 3957 19B0 102700                  DB       010H,027H,000H ; 10000
 3958 19B3 E80300                  DB       0E8H,003H,000H ; 1000
 3959 19B6 640000                  DB       064H,000H,000H ; 100
 3960 19B9 0A0000                  DB       00AH,000H,000H ; 10
 3961 19BC 010000                  DB       001H,000H,000H ; 1
 3962                   ;
 3963 19BF 215417       NEGAFT:    LD       HL,INVSGN   ; Negate result
 3964 19C2 E3                      EX       (SP),HL     ; To be done after call
 3965 19C3 E9                      JP       (HL)        ; Return to caller
 3966                   ;
 3967 19C4 CD5C17       SQR:       CALL     STAKFP      ; Put value on stack
 3968 19C7 21A919                  LD       HL,HALF     ; Set power to 1/2
 3969 19CA CD6917                  CALL     PHLTFP      ; Move 1/2 to FPREG
 3970                   ;
 3971 19CD C1           POWER:     POP      BC          ; Get base
 3972 19CE D1                      POP      DE
 3973 19CF CD2B17                  CALL     TSTSGN      ; Test sign of power
 3974 19D2 78                      LD       A,B         ; Get exponent of base
 3975 19D3 CA121A                  JP       Z,EXP       ; Make result 1 if zero
 3976 19D6 F2DD19                  JP       P,POWER1    ; Positive base - Ok
 3977 19D9 B7                      OR       A           ; Zero to negative powe
 3978 19DA CA8704                  JP       Z,DZERR     ; Yes - ?/0 Error
 3979 19DD B7           POWER1:    OR       A           ; Base zero?
 3980 19DE CA4C15                  JP       Z,SAVEXP    ; Yes - Return zero
 3981 19E1 D5                      PUSH     DE          ; Save base
 3982 19E2 C5                      PUSH     BC
 3983 19E3 79                      LD       A,C         ; Get MSB of base
 3984 19E4 F67F                    OR       01111111B   ; Get sign status
 3985 19E6 CD7717                  CALL     BCDEFP      ; Move power to BCDE
 3986 19E9 F2FA19                  JP       P,POWER2    ; Positive base - Ok
 3987 19EC D5                      PUSH     DE          ; Save power
 3988 19ED C5                      PUSH     BC
 3989 19EE CDFE17                  CALL     INT         ; Get integer of power
 3990 19F1 C1                      POP      BC          ; Restore power
 3991 19F2 D1                      POP      DE
 3992 19F3 F5                      PUSH     AF          ; MSB of base
 3993 19F4 CDA617                  CALL     CMPNUM      ; Power an integer?
 3994 19F7 E1                      POP      HL          ; Restore MSB of base
 3995 19F8 7C                      LD       A,H         ; but don't affect flag
 3996 19F9 1F                      RRA                  ; Exponent odd or even?
 3997 19FA E1           POWER2:    POP      HL          ; Restore MSB and expon
 3998 19FB 222B81                  LD       (FPREG+2),HL ; Save base in FPREG
 3999 19FE E1                      POP      HL          ; LSBs of base
 4000 19FF 222981                  LD       (FPREG),HL  ; Save in FPREG
 4001 1A02 DCBF19                  CALL     C,NEGAFT    ; Odd power - Negate re
 4002 1A05 CC5417                  CALL     Z,INVSGN    ; Negative base - Negat
 4003 1A08 D5                      PUSH     DE          ; Save power
 4004 1A09 C5                      PUSH     BC
 4005 1A0A CDDF15                  CALL     LOG         ; Get LOG of base
 4006 1A0D C1                      POP      BC          ; Restore power
 4007 1A0E D1                      POP      DE
 4008 1A0F CD2016                  CALL     FPMULT      ; Multiply LOG by power
 4009                   ;
 4010 1A12 CD5C17       EXP:       CALL     STAKFP      ; Put value on stack
 4011 1A15 013881                  LD       BC,08138H   ; BCDE = 1/Ln(2)
 4012 1A18 113BAA                  LD       DE,0AA3BH
 4013 1A1B CD2016                  CALL     FPMULT      ; Multiply value by 1/L
 4014 1A1E 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4015 1A21 FE88                    CP       80H+8       ; Is it in range?
 4016 1A23 D20717                  JP       NC,OVTST1   ; No - Test for overflo
 4017 1A26 CDFE17                  CALL     INT         ; Get INT of FPREG
 4018 1A29 C680                    ADD      A,80H       ; For excess 128
 4019 1A2B C602                    ADD      A,2         ; Exponent > 126?
 4020 1A2D DA0717                  JP       C,OVTST1    ; Yes - Test for overfl
 4021 1A30 F5                      PUSH     AF          ; Save scaling factor
 4022 1A31 21CE15                  LD       HL,UNITY    ; Point to 1.
 4023 1A34 CDD614                  CALL     ADDPHL      ; Add 1 to FPREG
 4024 1A37 CD1716                  CALL     MULLN2      ; Multiply by LN(2)
 4025 1A3A F1                      POP      AF          ; Restore scaling facto
 4026 1A3B C1                      POP      BC          ; Restore exponent
 4027 1A3C D1                      POP      DE
 4028 1A3D F5                      PUSH     AF          ; Save scaling factor
 4029 1A3E CDE214                  CALL     SUBCDE      ; Subtract exponent fro
 4030 1A41 CD5417                  CALL     INVSGN      ; Negate result
 4031 1A44 21521A                  LD       HL,EXPTAB   ; Coefficient table
 4032 1A47 CD821A                  CALL     SMSER1      ; Sum the series
 4033 1A4A 110000                  LD       DE,0        ; Zero LSBs
 4034 1A4D C1                      POP      BC          ; Scaling factor
 4035 1A4E 4A                      LD       C,D         ; Zero MSB
 4036 1A4F C32016                  JP       FPMULT      ; Scale result to corre
 4037                   ;
 4038 1A52 08           EXPTAB:    DB       8           ; Table used by EXP
 4039 1A53 402E9474                DB       040H,02EH,094H,074H ; -1/7! (-1/504
 4040 1A57 704F2E77                DB       070H,04FH,02EH,077H ;  1/6! ( 1/720
 4041 1A5B 6E02887A                DB       06EH,002H,088H,07AH ; -1/5! (-1/120
 4042 1A5F E6A02A7C                DB       0E6H,0A0H,02AH,07CH ;  1/4! ( 1/24)
 4043 1A63 50AAAA7E                DB       050H,0AAH,0AAH,07EH ; -1/3! (-1/6)
 4044 1A67 FFFF7F7F                DB       0FFH,0FFH,07FH,07FH ;  1/2! ( 1/2)
 4045 1A6B 00008081                DB       000H,000H,080H,081H ; -1/1! (-1/1)
 4046 1A6F 00000081                DB       000H,000H,000H,081H ;  1/0! ( 1/1)
 4047                   ;
 4048 1A73 CD5C17       SUMSER:    CALL     STAKFP      ; Put FPREG on stack
 4049 1A76 111E16                  LD       DE,MULT     ; Multiply by "X"
 4050 1A79 D5                      PUSH     DE          ; To be done after
 4051 1A7A E5                      PUSH     HL          ; Save address of table
 4052 1A7B CD7717                  CALL     BCDEFP      ; Move FPREG to BCDE
 4053 1A7E CD2016                  CALL     FPMULT      ; Square the value
 4054 1A81 E1                      POP      HL          ; Restore address of ta
 4055 1A82 CD5C17       SMSER1:    CALL     STAKFP      ; Put value on stack
 4056 1A85 7E                      LD       A,(HL)      ; Get number of coeffic
 4057 1A86 23                      INC      HL          ; Point to start of tab
 4058 1A87 CD6917                  CALL     PHLTFP      ; Move coefficient to F
 4059 1A8A 06                      DB       06H         ; Skip "POP AF"
 4060 1A8B F1           SUMLP:     POP      AF          ; Restore count
 4061 1A8C C1                      POP      BC          ; Restore number
 4062 1A8D D1                      POP      DE
 4063 1A8E 3D                      DEC      A           ; Cont coefficients
 4064 1A8F C8                      RET      Z           ; All done
 4065 1A90 D5                      PUSH     DE          ; Save number
 4066 1A91 C5                      PUSH     BC
 4067 1A92 F5                      PUSH     AF          ; Save count
 4068 1A93 E5                      PUSH     HL          ; Save address in table
 4069 1A94 CD2016                  CALL     FPMULT      ; Multiply FPREG by BCD
 4070 1A97 E1                      POP      HL          ; Restore address in ta
 4071 1A98 CD7A17                  CALL     LOADFP      ; Number at HL to BCDE
 4072 1A9B E5                      PUSH     HL          ; Save address in table
 4073 1A9C CDE514                  CALL     FPADD       ; Add coefficient to FP
 4074 1A9F E1                      POP      HL          ; Restore address in ta
 4075 1AA0 C38B1A                  JP       SUMLP       ; More coefficients
 4076                   ;
 4077 1AA3 CD2B17       RND:       CALL     TSTSGN      ; Test sign of FPREG
 4078 1AA6 215E80                  LD       HL,SEED+2   ; Random number seed
 4079 1AA9 FA041B                  JP       M,RESEED    ; Negative - Re-seed
 4080 1AAC 217F80                  LD       HL,LSTRND   ; Last random number
 4081 1AAF CD6917                  CALL     PHLTFP      ; Move last RND to FPRE
 4082 1AB2 215E80                  LD       HL,SEED+2   ; Random number seed
 4083 1AB5 C8                      RET      Z           ; Return if RND(0)
 4084 1AB6 86                      ADD      A,(HL)      ; Add (SEED)+2)
 4085 1AB7 E607                    AND      00000111B   ; 0 to 7
 4086 1AB9 0600                    LD       B,0
 4087 1ABB 77                      LD       (HL),A      ; Re-save seed
 4088 1ABC 23                      INC      HL          ; Move to coefficient t
 4089 1ABD 87                      ADD      A,A         ; 4 bytes
 4090 1ABE 87                      ADD      A,A         ; per entry
 4091 1ABF 4F                      LD       C,A         ; BC = Offset into tabl
 4092 1AC0 09                      ADD      HL,BC       ; Point to coefficient
 4093 1AC1 CD7A17                  CALL     LOADFP      ; Coefficient to BCDE
 4094 1AC4 CD2016                  CALL     FPMULT      ;       ; Multiply FPRE
 4095 1AC7 3A5D80                  LD       A,(SEED+1)  ; Get (SEED+1)
 4096 1ACA 3C                      INC      A           ; Add 1
 4097 1ACB E603                    AND      00000011B   ; 0 to 3
 4098 1ACD 0600                    LD       B,0
 4099 1ACF FE01                    CP       1           ; Is it zero?
 4100 1AD1 88                      ADC      A,B         ; Yes - Make it 1
 4101 1AD2 325D80                  LD       (SEED+1),A  ; Re-save seed
 4102 1AD5 21081B                  LD       HL,RNDTAB-4 ; Addition table
 4103 1AD8 87                      ADD      A,A         ; 4 bytes
 4104 1AD9 87                      ADD      A,A         ; per entry
 4105 1ADA 4F                      LD       C,A         ; BC = Offset into tabl
 4106 1ADB 09                      ADD      HL,BC       ; Point to value
 4107 1ADC CDD614                  CALL     ADDPHL      ; Add value to FPREG
 4108 1ADF CD7717       RND1:      CALL     BCDEFP      ; Move FPREG to BCDE
 4109 1AE2 7B                      LD       A,E         ; Get LSB
 4110 1AE3 59                      LD       E,C         ; LSB = MSB
 4111 1AE4 EE4F                    XOR      01001111B   ; Fiddle around
 4112 1AE6 4F                      LD       C,A         ; New MSB
 4113 1AE7 3680                    LD       (HL),80H    ; Set exponent
 4114 1AE9 2B                      DEC      HL          ; Point to MSB
 4115 1AEA 46                      LD       B,(HL)      ; Get MSB
 4116 1AEB 3680                    LD       (HL),80H    ; Make value -0.5
 4117 1AED 215C80                  LD       HL,SEED     ; Random number seed
 4118 1AF0 34                      INC      (HL)        ; Count seed
 4119 1AF1 7E                      LD       A,(HL)      ; Get seed
 4120 1AF2 D6AB                    SUB      171         ; Do it modulo 171
 4121 1AF4 C2FB1A                  JP       NZ,RND2     ; Non-zero - Ok
 4122 1AF7 77                      LD       (HL),A      ; Zero seed
 4123 1AF8 0C                      INC      C           ; Fillde about
 4124 1AF9 15                      DEC      D           ; with the
 4125 1AFA 1C                      INC      E           ; number
 4126 1AFB CD3615       RND2:      CALL     BNORM       ; Normalise number
 4127 1AFE 217F80                  LD       HL,LSTRND   ; Save random number
 4128 1B01 C38317                  JP       FPTHL       ; Move FPREG to last an
 4129                   ;
 4130 1B04 77           RESEED:    LD       (HL),A      ; Re-seed random number
 4131 1B05 2B                      DEC      HL
 4132 1B06 77                      LD       (HL),A
 4133 1B07 2B                      DEC      HL
 4134 1B08 77                      LD       (HL),A
 4135 1B09 C3DF1A                  JP       RND1        ; Return RND seed
 4136                   ;
 4137 1B0C 68B14668     RNDTAB:    DB       068H,0B1H,046H,068H ; Table used by
 4138 1B10 99E99269                DB       099H,0E9H,092H,069H
 4139 1B14 10D17568                DB       010H,0D1H,075H,068H
 4140                   ;
 4141 1B18 21621B       COS:       LD       HL,HALFPI   ; Point to PI/2
 4142 1B1B CDD614                  CALL     ADDPHL      ; Add it to PPREG
 4143 1B1E CD5C17       SIN:       CALL     STAKFP      ; Put angle on stack
 4144 1B21 014983                  LD       BC,8349H    ; BCDE = 2 PI
 4145 1B24 11DB0F                  LD       DE,0FDBH
 4146 1B27 CD6C17                  CALL     FPBCDE      ; Move 2 PI to FPREG
 4147 1B2A C1                      POP      BC          ; Restore angle
 4148 1B2B D1                      POP      DE
 4149 1B2C CD8116                  CALL     DVBCDE      ; Divide angle by 2 PI
 4150 1B2F CD5C17                  CALL     STAKFP      ; Put it on stack
 4151 1B32 CDFE17                  CALL     INT         ; Get INT of result
 4152 1B35 C1                      POP      BC          ; Restore number
 4153 1B36 D1                      POP      DE
 4154 1B37 CDE214                  CALL     SUBCDE      ; Make it 0 <= value < 
 4155 1B3A 21661B                  LD       HL,QUARTR   ; Point to 0.25
 4156 1B3D CDDC14                  CALL     SUBPHL      ; Subtract value from 0
 4157 1B40 CD2B17                  CALL     TSTSGN      ; Test sign of value
 4158 1B43 37                      SCF                  ; Flag positive
 4159 1B44 F24E1B                  JP       P,SIN1      ; Positive - Ok
 4160 1B47 CDD314                  CALL     ROUND       ; Add 0.5 to value
 4161 1B4A CD2B17                  CALL     TSTSGN      ; Test sign of value
 4162 1B4D B7                      OR       A           ; Flag negative
 4163 1B4E F5           SIN1:      PUSH     AF          ; Save sign
 4164 1B4F F45417                  CALL     P,INVSGN    ; Negate value if posit
 4165 1B52 21661B                  LD       HL,QUARTR   ; Point to 0.25
 4166 1B55 CDD614                  CALL     ADDPHL      ; Add 0.25 to value
 4167 1B58 F1                      POP      AF          ; Restore sign
 4168 1B59 D45417                  CALL     NC,INVSGN   ; Negative - Make posit
 4169 1B5C 216A1B                  LD       HL,SINTAB   ; Coefficient table
 4170 1B5F C3731A                  JP       SUMSER      ; Evaluate sum of serie
 4171                   ;
 4172 1B62 DB0F4981     HALFPI:    DB       0DBH,00FH,049H,081H ; 1.5708 (PI/2)
 4173                   ;
 4174 1B66 0000007F     QUARTR:    DB       000H,000H,000H,07FH ; 0.25
 4175                   ;
 4176 1B6A 05           SINTAB:    DB       5           ; Table used by SIN
 4177 1B6B BAD71E86                DB       0BAH,0D7H,01EH,086H ; 39.711
 4178 1B6F 64269987                DB       064H,026H,099H,087H ;-76.575
 4179 1B73 58342387                DB       058H,034H,023H,087H ; 81.602
 4180 1B77 E05DA586                DB       0E0H,05DH,0A5H,086H ;-41.342
 4181 1B7B DA0F4983                DB       0DAH,00FH,049H,083H ; 6.2832
 4182                   ;
 4183 1B7F CD5C17       TAN:       CALL     STAKFP      ; Put angle on stack
 4184 1B82 CD1E1B                  CALL     SIN         ; Get SIN of angle
 4185 1B85 C1                      POP      BC          ; Restore angle
 4186 1B86 E1                      POP      HL
 4187 1B87 CD5C17                  CALL     STAKFP      ; Save SIN of angle
 4188 1B8A EB                      EX       DE,HL       ; BCDE = Angle
 4189 1B8B CD6C17                  CALL     FPBCDE      ; Angle to FPREG
 4190 1B8E CD181B                  CALL     COS         ; Get COS of angle
 4191 1B91 C37F16                  JP       DIV         ; TAN = SIN / COS
 4192                   ;
 4193 1B94 CD2B17       ATN:       CALL     TSTSGN      ; Test sign of value
 4194 1B97 FCBF19                  CALL     M,NEGAFT    ; Negate result after i
 4195 1B9A FC5417                  CALL     M,INVSGN    ; Negate value if -ve
 4196 1B9D 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4197 1BA0 FE81                    CP       81H         ; Number less than 1?
 4198 1BA2 DAB11B                  JP       C,ATN1      ; Yes - Get arc tangnt
 4199 1BA5 010081                  LD       BC,8100H    ; BCDE = 1
 4200 1BA8 51                      LD       D,C
 4201 1BA9 59                      LD       E,C
 4202 1BAA CD8116                  CALL     DVBCDE      ; Get reciprocal of num
 4203 1BAD 21DC14                  LD       HL,SUBPHL   ; Sub angle from PI/2
 4204 1BB0 E5                      PUSH     HL          ; Save for angle > 1
 4205 1BB1 21BB1B       ATN1:      LD       HL,ATNTAB   ; Coefficient table
 4206 1BB4 CD731A                  CALL     SUMSER      ; Evaluate sum of serie
 4207 1BB7 21621B                  LD       HL,HALFPI   ; PI/2 - angle in case 
 4208 1BBA C9                      RET                  ; Number > 1 - Sub from
 4209                   ;
 4210 1BBB 09           ATNTAB:    DB       9           ; Table used by ATN
 4211 1BBC 4AD73B78                DB       04AH,0D7H,03BH,078H ; 1/17
 4212 1BC0 026E847B                DB       002H,06EH,084H,07BH ;-1/15
 4213 1BC4 FEC12F7C                DB       0FEH,0C1H,02FH,07CH ; 1/13
 4214 1BC8 74319A7D                DB       074H,031H,09AH,07DH ;-1/11
 4215 1BCC 843D5A7D                DB       084H,03DH,05AH,07DH ; 1/9
 4216 1BD0 C87F917E                DB       0C8H,07FH,091H,07EH ;-1/7
 4217 1BD4 E4BB4C7E                DB       0E4H,0BBH,04CH,07EH ; 1/5
 4218 1BD8 6CAAAA7F                DB       06CH,0AAH,0AAH,07FH ;-1/3
 4219 1BDC 00000081                DB       000H,000H,000H,081H ; 1/1
 4220                   ;
 4221                   
 4222 1BE0 C9           ARET:      RET                  ; A RETurn instruction
 4223                   ;
 4224 1BE1 D7           GETINP:    RST      10H         ;input a character
 4225 1BE2 C9                      RET
 4226                   ;
 4227 1BE3              CLS:
 4228 1BE3 3E0C                    LD       A,CS        ; ASCII Clear screen
 4229 1BE5 C3191D                  JP       MONOUT      ; Output character
 4230                   ;
 4231 1BE8 CDAA14       WIDTH:     CALL     GETINT      ; Get integer 0-255
 4232 1BEB 7B                      LD       A,E         ; Width to A
 4233 1BEC 328780                  LD       (LWIDTH),A  ; Set width
 4234 1BEF C9                      RET
 4235                   ;
 4236 1BF0 CD490D       LINES:     CALL     GETNUM      ; Get a number
 4237 1BF3 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 4238 1BF6 ED538B80                LD       (LINESC),DE ; Set lines counter
 4239 1BFA ED538D80                LD       (LINESN),DE ; Set lines number
 4240 1BFE C9                      RET
 4241                   ;
 4242 1BFF CD8E09       DEEK:      CALL     DEINT       ; Get integer -32768 to
 4243 1C02 D5                      PUSH     DE          ; Save number
 4244 1C03 E1                      POP      HL          ; Number to HL
 4245 1C04 46                      LD       B,(HL)      ; Get LSB of contents
 4246 1C05 23                      INC      HL
 4247 1C06 7E                      LD       A,(HL)      ; Get MSB of contents
 4248 1C07 C30411                  JP       ABPASS      ; Return integer AB
 4249                   ;
 4250 1C0A CD490D       DOKE:      CALL     GETNUM      ; Get a number
 4251 1C0D CD8E09                  CALL     DEINT       ; Get integer -32768 to
 4252 1C10 D5                      PUSH     DE          ; Save address
 4253 1C11 CD5207                  CALL     CHKSYN      ; Make sure ',' follows
 4254 1C14 2C                      DB       ','
 4255 1C15 CD490D                  CALL     GETNUM      ; Get a number
 4256 1C18 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 4257 1C1B E3                      EX       (SP),HL     ; Save value,get addres
 4258 1C1C 73                      LD       (HL),E      ; Save LSB of value
 4259 1C1D 23                      INC      HL
 4260 1C1E 72                      LD       (HL),D      ; Save MSB of value
 4261 1C1F E1                      POP      HL          ; Restore code string a
 4262 1C20 C9                      RET
 4263                   ;
 4264                   
 4265                   ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 4266                   ;
 4267 1C21 CD4C0D       HEX:       CALL     TSTNUM      ; Verify it's a number
 4268 1C24 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 4269 1C27 C5                      PUSH     BC          ; Save contents of BC
 4270 1C28 212E81                  LD       HL,PBUFF
 4271 1C2B 7A                      LD       A,D         ; Get high order into A
 4272 1C2C FE00                    CP       0
 4273 1C2E 280C                    JR       Z,HEX2      ; Skip output if both h
 4274 1C30 CD591C                  CALL     BYT2ASC     ; Convert D to ASCII
 4275 1C33 78                      LD       A,B
 4276 1C34 FE30                    CP       '0'
 4277 1C36 2802                    JR       Z,HEX1      ; Don't store high digi
 4278 1C38 70                      LD       (HL),B      ; Store it to PBUFF
 4279 1C39 23                      INC      HL          ; Next location
 4280 1C3A 71           HEX1:      LD       (HL),C      ; Store C to PBUFF+1
 4281 1C3B 23                      INC      HL          ; Next location
 4282 1C3C 7B           HEX2:      LD       A,E         ; Get lower byte
 4283 1C3D CD591C                  CALL     BYT2ASC     ; Convert E to ASCII
 4284 1C40 7A                      LD       A,D
 4285 1C41 FE00                    CP       0
 4286 1C43 2005                    JR       NZ,HEX3     ; If upper byte was not
 4287 1C45 78                      LD       A,B
 4288 1C46 FE30                    CP       '0'         ; If high digit of lowe
 4289 1C48 2802                    JR       Z,HEX4
 4290 1C4A 70           HEX3:      LD       (HL),B      ; to PBUFF+2
 4291 1C4B 23                      INC      HL          ; Next location
 4292 1C4C 71           HEX4:      LD       (HL),C      ; to PBUFF+3
 4293 1C4D 23                      INC      HL          ; PBUFF+4 to zero
 4294 1C4E AF                      XOR      A           ; Terminating character
 4295 1C4F 77                      LD       (HL),A      ; Store zero to termina
 4296 1C50 23                      INC      HL          ; Make sure PBUFF is te
 4297 1C51 77                      LD       (HL),A      ; Store the double zero
 4298 1C52 C1                      POP      BC          ; Get BC back
 4299 1C53 212E81                  LD       HL,PBUFF    ; Reset to start of PBU
 4300 1C56 C3B211                  JP       STR1        ; Convert the PBUFF to 
 4301                   ;
 4302 1C59 47           BYT2ASC    LD       B,A         ; Save original value
 4303 1C5A E60F                    AND      0FH         ; Strip off upper nybbl
 4304 1C5C FE0A                    CP       0AH         ; 0-9?
 4305 1C5E 3802                    JR       C,ADD30     ; If A-F, add 7 more
 4306 1C60 C607                    ADD      A,07H       ; Bring value up to ASC
 4307 1C62 C630         ADD30      ADD      A,30H       ; And make ASCII
 4308 1C64 4F                      LD       C,A         ; Save converted char t
 4309 1C65 78                      LD       A,B         ; Retrieve original val
 4310 1C66 0F                      RRCA                 ; and Rotate it right
 4311 1C67 0F                      RRCA
 4312 1C68 0F                      RRCA
 4313 1C69 0F                      RRCA
 4314 1C6A E60F                    AND      0FH         ; Mask off upper nybble
 4315 1C6C FE0A                    CP       0AH         ; 0-9? < A hex?
 4316 1C6E 3802                    JR       C,ADD301    ; Skip Add 7
 4317 1C70 C607                    ADD      A,07H       ; Bring it up to ASCII 
 4318 1C72 C630         ADD301     ADD      A,30H       ; And make it full ASCI
 4319 1C74 47                      LD       B,A         ; Store high order byte
 4320 1C75 C9                      RET
 4321                   ;
 4322                   ; Convert "&Hnnnn" to FPREG
 4323                   ; Gets a character from (HL) checks for Hexadecimal ASC
 4324                   ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0
 4325 1C76 EB           HEXTFP     EX       DE,HL       ; Move code string poin
 4326 1C77 210000                  LD       HL,0000H    ; Zero out the value
 4327 1C7A CD8F1C                  CALL     GETHEX      ; Check the number for 
 4328 1C7D DAAF1C                  JP       C,HXERR     ; First value wasn't he
 4329 1C80 1805                    JR       HEXLP1      ; Convert first charact
 4330 1C82 CD8F1C       HEXLP      CALL     GETHEX      ; Get second and addtio
 4331 1C85 381F                    JR       C,HEXIT     ; Exit if not a hex cha
 4332 1C87 29           HEXLP1     ADD      HL,HL       ; Rotate 4 bits to the 
 4333 1C88 29                      ADD      HL,HL
 4334 1C89 29                      ADD      HL,HL
 4335 1C8A 29                      ADD      HL,HL
 4336 1C8B B5                      OR       L           ; Add in D0-D3 into L
 4337 1C8C 6F                      LD       L,A         ; Save new value
 4338 1C8D 18F3                    JR       HEXLP       ; And continue until al
 4339                   ;
 4340 1C8F 13           GETHEX     INC      DE          ; Next location
 4341 1C90 1A                      LD       A,(DE)      ; Load character at poi
 4342 1C91 FE20                    CP       ' '
 4343 1C93 CA8F1C                  JP       Z,GETHEX    ; Skip spaces
 4344 1C96 D630                    SUB      30H         ; Get absolute value
 4345 1C98 D8                      RET      C           ; < "0", error
 4346 1C99 FE0A                    CP       0AH
 4347 1C9B 3805                    JR       C,NOSUB7    ; Is already in the ran
 4348 1C9D D607                    SUB      07H         ; Reduce to A-F
 4349 1C9F FE0A                    CP       0AH         ; Value should be $0A-$
 4350 1CA1 D8                      RET      C           ; CY set if was :      
 4351 1CA2 FE10         NOSUB7     CP       10H         ; > Greater than "F"?
 4352 1CA4 3F                      CCF
 4353 1CA5 C9                      RET                  ; CY set if it wasn't v
 4354                   
 4355 1CA6 EB           HEXIT      EX       DE,HL       ; Value into DE, Code s
 4356 1CA7 7A                      LD       A,D         ; Load DE into AC
 4357 1CA8 4B                      LD       C,E         ; For prep to
 4358 1CA9 E5                      PUSH     HL
 4359 1CAA CD0311                  CALL     ACPASS      ; ACPASS to set AC as i
 4360 1CAD E1                      POP      HL
 4361 1CAE C9                      RET
 4362                   ;
 4363 1CAF 1E26         HXERR:     LD       E,HX        ; ?HEX Error
 4364 1CB1 C39804                  JP       ERROR
 4365                   ;
 4366                   ; BIN$(NN) Convert integer to a 1-16 char binary string
 4367 1CB4 CD4C0D       BIN:       CALL     TSTNUM      ; Verify it's a number
 4368 1CB7 CD8E09                  CALL     DEINT       ; Get integer -32768 to
 4369 1CBA C5           BIN2:      PUSH     BC          ; Save contents of BC
 4370 1CBB 212E81                  LD       HL,PBUFF
 4371 1CBE 0611                    LD       B,17        ; One higher than max c
 4372 1CC0              ZEROSUP:                        ; Suppress leading zero
 4373 1CC0 05                      DEC      B           ; Max 16 chars
 4374 1CC1 78                      LD       A,B
 4375 1CC2 FE01                    CP       01H
 4376 1CC4 2808                    JR       Z,BITOUT    ; Always output at leas
 4377 1CC6 CB13                    RL       E
 4378 1CC8 CB12                    RL       D
 4379 1CCA 30F4                    JR       NC,ZEROSUP
 4380 1CCC 1804                    JR       BITOUT2
 4381 1CCE              BITOUT:
 4382 1CCE CB13                    RL       E
 4383 1CD0 CB12                    RL       D           ; Top bit now in carry
 4384 1CD2              BITOUT2:
 4385 1CD2 3E30                    LD       A,'0'       ; Char for '0'
 4386 1CD4 CE00                    ADC      A,0         ; If carry set then '0'
 4387 1CD6 77                      LD       (HL),A
 4388 1CD7 23                      INC      HL
 4389 1CD8 05                      DEC      B
 4390 1CD9 20F3                    JR       NZ,BITOUT
 4391 1CDB AF                      XOR      A           ; Terminating character
 4392 1CDC 77                      LD       (HL),A      ; Store zero to termina
 4393 1CDD 23                      INC      HL          ; Make sure PBUFF is te
 4394 1CDE 77                      LD       (HL),A      ; Store the double zero
 4395 1CDF C1                      POP      BC
 4396 1CE0 212E81                  LD       HL,PBUFF
 4397 1CE3 C3B211                  JP       STR1
 4398                   ;
 4399                   ; Convert "&Bnnnn" to FPREG
 4400                   ; Gets a character from (HL) checks for Binary ASCII nu
 4401 1CE6 EB           BINTFP:    EX       DE,HL       ; Move code string poin
 4402 1CE7 210000                  LD       HL,0000H    ; Zero out the value
 4403 1CEA CD031D                  CALL     CHKBIN      ; Check the number for 
 4404 1CED DA111D                  JP       C,BINERR    ; First value wasn't bi
 4405 1CF0 D630         BINIT:     SUB      '0'
 4406 1CF2 29                      ADD      HL,HL       ; Rotate HL left
 4407 1CF3 B5                      OR       L
 4408 1CF4 6F                      LD       L,A
 4409 1CF5 CD031D                  CALL     CHKBIN      ; Get second and addtio
 4410 1CF8 30F6                    JR       NC,BINIT    ; Process if a bin char
 4411 1CFA EB                      EX       DE,HL       ; Value into DE, Code s
 4412 1CFB 7A                      LD       A,D         ; Load DE into AC
 4413 1CFC 4B                      LD       C,E         ; For prep to
 4414 1CFD E5                      PUSH     HL
 4415 1CFE CD0311                  CALL     ACPASS      ; ACPASS to set AC as i
 4416 1D01 E1                      POP      HL
 4417 1D02 C9                      RET
 4418                   ;
 4419                   ; Char is in A, NC if char is 0 or 1
 4420 1D03 13           CHKBIN:    INC      DE
 4421 1D04 1A                      LD       A,(DE)
 4422 1D05 FE20                    CP       ' '
 4423 1D07 CA031D                  JP       Z,CHKBIN    ; Skip spaces
 4424 1D0A FE30                    CP       '0'         ; Set C if < '0'
 4425 1D0C D8                      RET      C
 4426 1D0D FE32                    CP       '2'
 4427 1D0F 3F                      CCF                  ; Set C if > '1'
 4428 1D10 C9                      RET
 4429                   ;
 4430 1D11 1E28         BINERR:    LD       E,BN        ; ?BIN Error
 4431 1D13 C39804                  JP       ERROR
 4432                   ;
 4433 1D16 C3DD00       JJUMP1:    JP       CSTART      ; Go and initialise
 4434                   ;
 4435 1D19 C30800       MONOUT:    JP       0008H       ; output a char
 4436                   ;
 4437 1D1C C30000       MONITR:    JP       0000H       ; Restart (Normally Mon
 4438                   ;
 4439 1D1F 3E00         INITST:    LD       A,0         ; Clear break flag
 4440 1D21 329280                  LD       (BRKFLG),A
 4441 1D24 C3E400                  JP       INIT
 4442                   ;
 4443 1D27 F5           TSTBIT:    PUSH     AF          ; Save bit mask
 4444 1D28 A0                      AND      B           ; Get common bits
 4445 1D29 C1                      POP      BC          ; Restore bit mask
 4446 1D2A B8                      CP       B           ; Same bit set?
 4447 1D2B 3E00                    LD       A,0         ; Return 0 in A
 4448 1D2D C9                      RET
 4449                   ;
 4450 1D2E CD5D07       OUTNCR:    CALL     OUTC        ; Output character in A
 4451 1D31 C3840B                  JP       PRCRLF      ; Output CRLF
 4452                   ;
 4453 1D34                         END
